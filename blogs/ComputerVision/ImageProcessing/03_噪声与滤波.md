---
title: 噪声与滤波
date: 2025/09/12
categories:
  - 图像处理
tags:
  - OpenCV
  - 图像增强
  - 图像噪声
  - 滤波器
---

## 1. 噪声（Noise）

图像噪声通常表现为局部的孤立像素点或小范围像素块，使图像出现明显的随机干扰。一般来说，噪声信号与图像的实际内容无关，它以无用信息的形式掺入图像，干扰视觉观察和后续处理。通俗地说，噪声会使图像看起来模糊或不清晰。

### 1.1 噪声来源与分类

1. ==图像获取过程中产生的噪声==：由图像传感器（CCD、CMOS）材料属性、工作环境、电子元器件和电路结构等因素引入。常见噪声类型：

- **高斯噪声（Gaussian Noise）**：像素值服从高斯分布，通常源自热噪声或电子器件噪声。
- **椒盐噪声（Salt-and-Pepper Noise）**：像素被随机置为最大或最小值，来源于传感器读写误差。
- **泊松噪声（Poisson Noise）**：噪声方差与信号强度相关，源于光子统计波动。
- **均值噪声（Uniform Noise）**：像素值在固定范围内随机分布，来源于量化误差或简单随机干扰。

2. ==图像传输和记录过程中产生的噪声==：由于传输介质、记录设备或图像处理环节的不完善引入。常见噪声类型：

- **斑点噪声（Speckle Noise）**：常见于 SAR 或医学超声图像，由相干信号干涉产生颗粒状退化。
- **周期性噪声（Periodic Noise）**：以周期性条纹或波纹出现，来源于机械震动或电磁干扰。
- **量化噪声（Quantization Noise）**：图像数据数字化过程中，由位深限制导致细节丢失或分辨率降低。

### 1.2 噪声模拟（椒盐、高斯）

==椒盐噪声==是指随机在图像上出现黑色（椒）或白色（盐）的像素点，也就是图像中的某些像素值突变为 0 或 255。一般是由于数据传输错误或图像采集中的传感器故障所造成的。

==高斯噪声==常见于自然环境中的噪声，符合高斯分布，即噪声值服从均值为零、方差为某值的正态分布，表现为图像上呈现为随机分布的细小亮点或暗点。。一般是由于传感器热噪声、电子电路干扰等产生的。

<div class="layout">

![1.1 Salt-and-Pepper Noise](/cv/ImageProcessing/03_xxx/01_noise1.jpg =360x)

![1.2 Gaussian Noise](/cv/ImageProcessing/03_xxx/02_noise2.jpg =360x)

</div>

:::: code-group
::: code-group-item 模拟椒盐噪声

```py
import cv2
import numpy as np

img = cv2.imread("01_sunset.jpg")  # 读取图像
noise1_img = np.copy(img)  # 复制一份图像用于添加噪声

sp_rate = 0.5    # 设置椒盐噪声的黑白比例
sp_amount = 0.1 # 设置噪声占总像素点的比例

H, W, C = noise1_img.shape
num_total = int(sp_amount * H * W)  # 总共要加噪声的像素点数
num_salt = int(num_total * sp_rate) # 盐噪声的数量
num_pepper = num_total - num_salt   # 椒噪声的数量

# 添加salt噪声（白点）
coords_salt_y = np.random.randint(0, H, num_salt)
coords_salt_x = np.random.randint(0, W, num_salt)
noise1_img[coords_salt_y, coords_salt_x] = [255, 255, 255]

# 添加pepper噪声（黑点）
coords_pepper_y = np.random.randint(0, H, num_pepper)
coords_pepper_x = np.random.randint(0, W, num_pepper)
noise1_img[coords_pepper_y, coords_pepper_x] = [0, 0, 0]

cv2.imwrite("01_noise1.jpg", noise1_img)
```

:::
::: code-group-item 模拟高斯噪声

```py
import cv2
import numpy as np

noise2_img = cv2.imread("01_sunset.jpg")
mean = 0    # 均值，控制噪声的亮度，mean越大，噪声越亮
sigma = 50  # 标准差，控制噪声强弱，sigma越大，噪声越强

# 生成符合正态（normal）分布的随机数噪声
gauss = np.random.normal(mean, sigma, noise2_img.shape)
noise2_img = noise2_img + gauss  # 添加噪声
noise2_img = np.clip(noise2_img, a_min=0, a_max=255)  # 限制像素范围 [0, 255]

cv2.imwrite("02_noise2-2.jpg", noise2_img)
```

:::
::::

### 1.3 噪声模拟（泊松、均值）

==泊松噪声（Poisson Noise）== 常见于 光子计数、医学影像、低光照摄影，因为成像过程就是随机到达的光子。噪声值服从泊松分布，泊松分布只有一个参数 λ，λ 越大，噪声越接近高斯噪声。直觉里的“泊松噪声”，会有“暗处颗粒强、亮处平滑”的感觉。

==均值噪声（Mean Noise）/ 均匀噪声（Uniform Noise）== 是一种最基础的噪声类型，每个像素被加上来自均匀分布的随机扰动，噪声强度取决于区间宽度。常见于 量化误差、采样误差、传感器或 ADC 电路噪声。

在图像/信号数字化的过程中，如果使用了均匀量化会引入均匀分布的误差。在一些低端相机、麦克风或传感器里，ADC（模数转换器）的抖动也会带来接近均匀分布的噪声，特别是在信号强度较低、没有主导噪声源时，这种均匀噪声会比较明显。

<div class="layout">

![1.3 Poisson Noise](/cv/ImageProcessing/03_xxx/03_noise3.jpg =360x)

![1.4 Mean Noise](/cv/ImageProcessing/03_xxx/04_noise4.jpg =360x)

</div>

:::: code-group
::: code-group-item 模拟泊松噪声

```py
import cv2, numpy as np

def add_poisson(img, scale=30.0):
    img = img.astype(np.float32) / 255.0  # [0,1]
    vals = 2 ** np.ceil(np.log2(scale))   # 控制噪声强度
    noisy = np.random.poisson(img * vals) / float(vals)
    noisy = np.clip(noisy, 0, 1)
    return (noisy * 255).astype(np.uint8)

img = cv2.imread("01_sunset.jpg")
# scale 越大 → 亮部噪声更细腻，暗部噪声相对更明显；
# scale 越小 → 整体噪声更夸张。
res = add_poisson(img, scale=50.0)
cv2.imwrite("03_noise3.jpg", res)
```

:::
::: code-group-item 模拟均值噪声

```py
import cv2
import numpy as np

img = cv2.imread("01_sunset.jpg")  # 读取原图
noise_img = np.copy(img).astype(np.int16)  # 用int16避免加噪溢出

low, high = -50, 50  # 控制噪声范围
noise = np.random.uniform(low, high, img.shape)  # 生成均匀噪声

# 加噪并裁剪到合法范围
noise_img = noise_img + noise
noise_img = np.clip(noise_img, 0, 255).astype(np.uint8)

cv2.imwrite("04_noise4.jpg", noise_img)
```

:::
::::

### 1.4 噪声模拟（斑点、量化）

==斑点噪声（Speckle Noise）== 是一种乘性噪声（multiplicative noise），不同于高斯/均匀/泊松的“加性噪声”。常见于 相干成像系统（比如雷达、超声、SAR 合成孔径雷达、医学超声），是由于波的相干叠加导致亮暗不均的“斑点状颗粒”。

==量化噪声（Quantization Noise）== 是由于数字信号有限比特数表示导致的误差。比如图像从 8 位降低到 4 位时，像素只能取更少的灰度级，原始值会被“四舍五入”到最近的量化等级。这种舍入误差本质上就是一种均匀噪声，范围大约在 ±0.5 个量化步长。

<div class="layout">

![1.5 Speckle Noise](/cv/ImageProcessing/03_xxx/05_noise5.jpg =360x)

![1.6 Quantization Noise](/cv/ImageProcessing/03_xxx/06_noise6.jpg =360x)

</div>

:::: code-group
::: code-group-item 模拟斑点噪声

```py
import cv2
import numpy as np

def add_speckle_noise(img, sigma=0.1):
    img = img.astype(np.float32) / 255.0
    noise = np.random.randn(*img.shape) * sigma
    noisy = img + img * noise
    noisy = np.clip(noisy, 0, 1)
    return (noisy * 255).astype(np.uint8)

img = cv2.imread("01_sunset.jpg")
# sigma 控制斑点强度，0.1–0.2 比较常见。
res_speckle = add_speckle_noise(img, sigma=0.2)
cv2.imwrite("05_noise5.jpg", res_speckle)
```

:::
::: code-group-item 模拟量化噪声

```py
import cv2
import numpy as np

def add_quantization_noise(img, bits=4):
    img = img.astype(np.float32) / 255.0
    levels = 2 ** bits
    quantized = np.floor(img * levels) / levels  # 模拟量化
    noisy = np.clip(quantized, 0, 1)  # 模拟量化
    return (noisy * 255).astype(np.uint8)  # 模拟量化

img = cv2.imread("01_sunset.jpg")
# bits 越低，量化噪声越明显。8 位（256级）：几乎无感；
# 2 位（4级）：能看到明显色带；1 位（2级）：非常夸张，几乎变成“像素艺术”。
res_quant = add_quantization_noise(img, bits=2)
cv2.imwrite("06_noise6.jpg", res_quant)
```

:::
::::

## 2. 平滑处理 (Smoothing)

### 2.1 目的与应用

在图像处理中，"平滑"是指减少图像中噪声或细节的过程，目的是让图像看起来更加平滑、柔和；或是突出主要特征，抑制不必要的细节。平滑操作常常用于噪声去除、边缘检测之前的预处理等任务。

- **噪声去除**：平滑操作能够有效减小噪声对图像质量的影响。
- **特征提取**：通过平滑去除细节，有助于在后续处理（如边缘检测、形态学处理等）中更好地提取关键特征。
- **图像压缩**：某些压缩算法依赖于图像的平滑化，以降低数据冗余。

打一个比方，人的脸上有痣啊、痘痘啊这些东西，平滑的去噪像是给脸上化妆，粉饰掉这些细节和瑕疵。典型的应用：视频降噪（摄像头视频流中的每一帧图像套上平滑滤波器）。

### 2.2 滑窗与卷积

==滑动窗口（Sliding Window）== 在算法中是一种技巧，或者说是一种解决问题的模版，常用于字符串、数组题目（比如最长子串、不重复子串、回文判断等）。它就是在一个序列上维护一个“区间”，不断滑动这个区间来统计/计算。在图像处理（二维数组）中，滑窗就是在图像矩阵上移动一个小窗口，提取局部邻域的像素信息。

<div class="layout">

![2.1 滑窗与卷积](/cv/ImageProcessing/03_xxx/07_slide1.png =360x)

![2.2 滑动窗口 GIF](/cv/ImageProcessing/03_xxx/07_slide2.gif =360x)

</div>

==卷积（Convolution）== 是通过两个函数 f 和 g 生成第 3 个函数的一种特殊的积分变换。**所谓两个函数的卷积，本质上就是先将一个函数翻转，然后进行滑动叠加**。叠加，在连续情况下指的是对两个函数的乘积求积分，在离散情况下就是加权求和。**图像处理中的卷积都是离散的。**

一维中的连续卷积/离散卷积公式：

$$
(f * g)(t) = \int_{-\infty}^{\infty} f(\tau)\, g(t - \tau)\, d\tau
$$

$$
(f * g)[n] = \sum_{m=-\infty}^{\infty} f[m]\, g[n-m]
$$

二维中的连续卷积/离散卷积公式：

$$
(f * g)(x, y) = \iint_{-\infty}^{\infty} f(\xi, \eta)\, g(x-\xi, y-\eta)\, d\xi\, d\eta
$$

$$
(f * g)[x,y] = \sum_{m=-\infty}^{\infty} \sum_{n=-\infty}^{\infty} f[m,n] \, g[x-m,\, y-n]
$$

深度学习中的卷积指的是卷积层，它引入了**卷积核的个数**这个概念，不同的卷积核用来学习不同的图像特征。而传统图像处理中的卷积只有三个重点参数：

1. ==卷积核大小（kernel size）==：就是滑窗的尺寸。常见 3×3, 5×5。之所以是奇数，因为奇数有单一的中心点，是对称的，可以让卷积做翻转的时候保持位置不变。如果是偶数，会导致“中心在像素间”的半像素偏移，不利于直观解释与实现。
2. ==步幅（stride）==：每次移动的步子有多大，通常为 1。
3. ==填充（padding）==：用于避免边界信息丢失。在滑窗的过程中，如果不填充边界，改变的只有中间的像素值，边缘像素是没有进行加权求和的。

前面说过，卷积就是通过两个函数 f 和 g 生成第 3 个函数，如果把图像的像素矩阵看作 f，那 g 是什么？在不同的卷积滤波器中，g 是不同参数的矩阵（卷积核）。

在滑动窗口的过程中，卷积核不断的与对应的像素矩阵进行对位乘法，然后加权求和。这些卷积核的值不是学出来的，而是人为设计好的、固定的一组参数矩阵，来源于数学推导或论文。

### 2.3 均值滤波器(卷积)

#### 2.3.1 原理与计算

均值滤波器的原理是，将每个像素值替换为其邻域内像素的平均值。所以它的卷积核很好理解，3x3 尺寸的值为 $\frac{1}{9}$，5x5 尺寸的值为 $\frac{1}{25}$，这里以 3x3 为例，卷积核可以写为：

$$
\begin{bmatrix}
\frac{1}{9} & \frac{1}{9} & \frac{1}{9} \\[0.5em]
\frac{1}{9} & \frac{1}{9} & \frac{1}{9} \\[0.5em]
\frac{1}{9} & \frac{1}{9} & \frac{1}{9}
\end{bmatrix}
=
\frac{1}{9}
\begin{bmatrix}
1 & 1 & 1 \\[0.5em]
1 & 1 & 1 \\[0.5em]
1 & 1 & 1
\end{bmatrix}
$$

拿 图 2.1 的矩阵数据做运算，第一步的计算结果如下：

$$
\begin{bmatrix}
12 & 55 & 30 \\[0.5em]
3 & 45 & 60 \\[0.5em]
25 & 10 & 90
\end{bmatrix}
\times
\frac{1}{9}
\begin{bmatrix}
1 & 1 & 1 \\[0.5em]
1 & 1 & 1 \\[0.5em]
1 & 1 & 1
\end{bmatrix}
= \frac{1}{9}\times330 = 36\frac{1}{3}
$$

在对 5x5 的图像用 3x3 卷积核进行运算，步幅为 1 的情况下，输出会变成 3x3 的尺寸。这个输出对应的是原图中的中心位置，边缘像素是没有变化的。

::: details 计算结果与位置替换的直观显示
![2.3 Valid 卷积计算结果](/cv/ImageProcessing/03_xxx/08_vc.png)
:::

#### 2.3.2 卷积模式与函数解析

在真实图像中的实际计算虽然也是如同这样，但大多数的现有算法默认会选择一种方式进行边缘填充，所以输出的结果还是 5x5。这些不同的模式也有他们的专业名词：

1. ==Valid 卷积(模式)==：也称为无填充卷积，滤波器仅在输入图像的有效区域内滑动，不会超出边界。因此，输出图像的大小会小于输入图像。如同我们刚才的计算。
2. ==Same 卷积(模式)==：也称为相同填充卷积，旨在保持输出图像的大小与输入图像相同。为了实现这一点，会在输入图像的边界添加适当的零填充。
3. ==Full 卷积(模式)==：也称为全填充卷积，会在输入图像周围添加更多的填充，使得滤波器可以完全覆盖输入图像的每个像素。这种模式下，输出图像的大小会比输入图像大。

在 OpenCV 中有两个函数都可以实现均值滤波，cv2.blur() 和 cv2.boxFilter()，两者共同的参数有这三个：

1. **src**：输入图像（可以是灰度或彩色）。
2. **ksize**：卷积核大小，例如 (3,3)，就是 3×3 的均值滤波。
3. **borderType**：边界填充方式。**在《基础操作》中 3.1 小节演示过，使用方式完全相同**。默认 BORDER_DEFAULT= BORDER_REFLECT_101。

```py
dst = cv2.blur(src, ksize, borderType=cv2.BORDER_DEFAULT)
dst = cv2.boxFilter(src, ddepth, ksize, normalize=True, borderType=cv2.BORDER_DEFAULT)
```

1. **ddepth**：图像的深度就是数据类型，一般都是 CV_8U。在写法上通常写 -1，表示和输入相同。
2. **normalize**：是否归一化。True 的话，结果是均值滤波，False 的话，就是求邻域的“和”而不是平均。领域求和一般是作为中间步骤，常用于 区域能量统计、积分图加速、特征提取，在这里就不细说了。

#### 2.3.3 实践应用

卷积是做**局部加权求和**，==卷积核越大==，每个输出像素的值会融合更多邻域信息（平滑效果更强），但细节会被“平均掉”（图像模糊）；==卷积核越小==，融合的邻域信息少（保留更多局部特征），但同时去噪或平滑能力会相对较弱。这是平滑卷积的一个普遍规律。

均值滤波对 **随机、均匀、非极端值噪声** 效果最佳（高斯、泊松、量化、均值）。对极端值噪声（椒盐）或乘性噪声（斑点）效果差，容易模糊。

```py
import cv2

img_mean = cv2.imread('04_noise4.jpg')
img_sp = cv2.imread('01_noise1.jpg')

img_mean_3x3 = cv2.blur(img_mean, (3,3))
img_mean_5x5 = cv2.blur(img_mean, (5,5))
img_sp_3x3 = cv2.blur(img_sp, (3,3))

cv2.imshow('Mean Noise', img_mean)
cv2.imshow('Mean Filter 3x3 on Mean Noise', img_mean_3x3)
cv2.imshow('Mean Filter 5x5 on Mean Noise', img_mean_5x5)
cv2.imshow('Salt-and-Pepper Noise', img_sp)
cv2.imshow('Mean Filter 3x3 on Salt-and-Pepper Noise', img_sp_3x3)
cv2.waitKey(0)
```

<div class="layout">

![2.4 均值噪声原图](/cv/ImageProcessing/03_xxx/04_noise4.jpg =360x)

![2.5 卷积核 3x3 去均值噪声](/cv/ImageProcessing/03_xxx/09_noise4_3x3.jpg =360x)

</div>

<div class="layout">

![2.6 卷积核 5x5 去均值噪声](/cv/ImageProcessing/03_xxx/09_noise4_5x5.jpg =360x)

![2.7 卷积核 3x3 去椒盐噪声](/cv/ImageProcessing/03_xxx/10_noise1_3x3.jpg =360x)

</div>

1. 均值滤波对图像边缘没有区分，边缘像素会被周围邻域平均，导致边界模糊。特别是高对比度边缘（如文字、建筑轮廓）会明显变平滑。边缘和平滑度难以兼顾。
2. 对彩色图像直接做均值滤波会把三个通道分别平均，对低饱和或亮度突变区域容易产生色彩漂移。
3. 卷积核越大，计算量越大（虽然 OpenCV 做了优化），但对实时处理或视频，过大的均值滤波会降低帧率。

### 2.4 高斯滤波器(卷积)

#### 2.4.1 运算原理与函数解析

高斯滤波器是一种加权平均滤波器，权值由高斯函数决定。x 和 y 是相对于卷积核中心的坐标；sigma(σ) 是标准差，控制平滑程度，σ 越大，平滑越强；卷积核值一般需要 归一化，使得总和等于 1。

$$
G(x, y) = \frac{1}{2\pi\sigma^2} \exp\Big(-\frac{x^2 + y^2}{2\sigma^2}\Big)
$$

高斯滤波的核心思想是中心像素权重大，越远的像素权重越小。因为它符合高斯分布(正态分布)的规律，是一个钟形曲线，2D 和 3D 的直观热力图表示如下（越靠近中心，能量越高，颜色越鲜艳）：

<div class="layout">

![2.8 高斯分布热力图 2D](/cv/ImageProcessing/03_xxx/11_hotmap2d.png =360x)

![2.9 高斯分布热力图 3D](/cv/ImageProcessing/03_xxx/11_hotmap3d.png =360x)

</div>

高斯滤波的卷积核是由高斯函数推导出的一个固定值，3x3 尺寸卷积核大概是这样一个矩阵（与 5x5 的样本矩阵之间的运算过程就不手动计算了，理解加权求和的计算方法就足够了）：

$$
\frac{1}{16}
\begin{bmatrix}
1 & 2 & 1 \\[0.5em]
2 & 4 & 2 \\[0.5em]
1 & 2 & 1
\end{bmatrix}
=
\begin{bmatrix}
0.0751 & 0.1238 & 0.0751 \\[0.5em]
0.1238 & 0.2042 & 0.1238 \\[0.5em]
0.0751 & 0.1238 & 0.0751
\end{bmatrix}
$$

在 OpenCV 中 cv2.GaussianBlur() 函数用于计算高斯滤波，ksize 必须为奇数；sigmaX 表示高斯核在 X 轴方向上的标准差；sigmaY 同理表示 Y 轴方向上的标准差，不过一般不写，默认为 0，表示与 sigmaX 相同。

```py
dst = cv2.GaussianBlur(src, ksize, sigmaX, sigmaY=0, borderType=cv2.BORDER_DEFAULT)
```

sigmaX 甚至都不用定义，OpenCV 中可以自动推算，ksize 为 3 时（sigma 约为 0.95），ksize 为 5 时（sigma 约等于 1.4），ksize 为 7 时（sigma 约为 2.0），推算的公式如下：

$$
\sigma\approx\left(\frac{ksize-1}{2}-1\right)+0.8
$$

如果是手动指定 sigmaX，一般取值范围在 [1, 3] 之间：

1. 小 σ（<1）：效果接近均值滤波，轻微平滑
2. 中等 σ（1~3）：常用，平衡去噪和细节
3. 大 σ（>5）：强烈模糊，常用于图像金字塔、缩放前平滑

#### 2.4.2 实践应用

理论上，Wiener 证明高斯滤波是去除高斯噪声的最优线性滤波器。对于低强度的随机噪声（波松、均值、量化）也能有一定程度的平滑。并且边缘保留比均值滤波更温和。

需要说明一下的是，在博客中，为了让噪声看起来更明显，所以我设置的噪声的强度比较高，滤波的效果看上去没有那么好。但在实际的图像中，一般不会这么多噪点。

:::: code-group
::: code-group-item 高斯滤波去噪

```py
import cv2

img_gaussian = cv2.imread('02_noise2.jpg')
img_poisson = cv2.imread('03_noise3.jpg')

img_g_3x3 = cv2.GaussianBlur(img_gaussian, (3,3), sigmaX=1.5)
img_p_3x3 = cv2.GaussianBlur(img_poisson, (3,3), sigmaX=1.5)

cv2.imshow('Gaussian Noise', img_gaussian)
cv2.imshow('Gaussian Filter 3x3 on Gaussian Noise', img_g_3x3)
cv2.imshow('Poisson Noise', img_poisson)
cv2.imshow('Gaussian Filter 3x3 on Poisson Noise', img_p_3x3)
cv2.waitKey(0)

cv2.imwrite('12_noise2_3x3.jpg', img_g_3x3)
cv2.imwrite('12_noise3_3x3.jpg', img_p_3x3)
```

:::

::: code-group-item 高斯函数热力图

```py
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # 用于3D绘图

# 定义二维高斯函数
def gaussian_2d(x, y, sigma=1.0):
    return (1 / (2 * np.pi * sigma**2)) * np.exp(-(x**2 + y**2) / (2 * sigma**2))

# 网格
size = 5  # 可以调节网格大小
x = np.linspace(-3, 3, 100)
y = np.linspace(-3, 3, 100)
X, Y = np.meshgrid(x, y)
Z = gaussian_2d(X, Y, sigma=1.0)

# 2D 热力图
plt.figure(figsize=(6,5))
plt.title("2D Gaussian Distribution")
plt.imshow(Z, extent=[-3,3,-3,3], origin='lower', cmap='viridis')
plt.colorbar(label="Value")
plt.xlabel("X")
plt.ylabel("Y")
plt.show()

# 3D 曲面图
fig = plt.figure(figsize=(7,5))
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='k', alpha=0.8)
ax.set_title("3D Gaussian Distribution")
ax.set_xlabel("X")
ax.set_ylabel("Y")
ax.set_zlabel("Z")
plt.show()
```

:::
::::

<div class="layout">

![2.10 高斯噪声](/cv/ImageProcessing/03_xxx/02_noise2.jpg =360x)

![2.11 高斯滤波 3x3 去高斯噪声](/cv/ImageProcessing/03_xxx/12_noise2_3x3.jpg =360x)

</div>

<div class="layout">

![2.12 泊松噪声](/cv/ImageProcessing/03_xxx/03_noise3.jpg =360x)

![2.13 高斯分布 3x3 去泊松噪声](/cv/ImageProcessing/03_xxx/12_noise3_3x3.jpg =360x)

</div>

1. 细节损失不可避免：卷积核越大，图像越模糊。
2. 无法处理极端噪声：椒盐噪声、斑点噪声效果有限。
3. 仍是线性滤波：对复杂噪声（乘性噪声、纹理干扰）不够鲁棒。

### 2.5 中值滤波器

中值滤波（Median Filtering）它的基本思想是：对于图像中的每个像素，将该像素的邻域内像素值按大小排序，然后用排序后的中位数值替代当前像素的值。还是拿 图 2.1 的 3x3 窗口，举例说明运算原理（实际运算应该会将矩阵展开，变成 1 维数组进行排序）：

$$
\begin{bmatrix}
12 & 55 & 30 \\[0.5em]
3 & 45 & 60 \\[0.5em]
25 & 10 & 90
\end{bmatrix}
\xrightarrow{\text{排序}}
\begin{bmatrix}
3 & 10 & 12 \\[0.5em]
25 & 30 & 45 \\[0.5em]
55 & 60 & 90
\end{bmatrix}
\xrightarrow{\text{取中位数}}
30
$$

在 OpenCV 中使用 cv2.medianBlur() 函数实现中值滤波，参数都讲过，需要注意的是这里读取的图像必须是单通道或三通道 8-bit（最常见）/16-bit（医学图、深度图） 图像。整数好排序，浮点数排序过程更复杂，所以 OpenCV 选择了只支持整数。另外这里的 ksize 不是元组，而是一个正奇数的数值。

```py
dst = cv2.medianBlur(src, ksize)
```

- **去噪效果好**：中值滤波能够有效去除椒盐噪声，因为椒盐噪声通常是极端的亮点或暗点，取均值容易拉偏，而中值滤波能够将这些极端值替换为邻域的中位数。与椒盐噪声同类型的还有 ==脉冲噪声、孤立点噪声==。
- **保边缘能力强**：相比均值滤波，中值滤波对图像的边缘信息影响较小，因为它不会对像素值进行平均化，而是通过排序选择合适的中位数来替换。
- **无需假设噪声分布**：与高斯滤波等方法不同，中值滤波不依赖于噪声的统计特性，因此对不同类型的噪声具有较好的鲁棒性。

```py
import cv2

img_sp = cv2.imread('01_noise1.jpg')
img1 = cv2.medianBlur(img_sp, 3)

cv2.imshow('Salt and Pepper Noise', img_sp)
cv2.imshow('Median Filter 3x3 on SP Noise', img1)
cv2.waitKey(0)
```

<div class="layout">

![2.14 椒盐噪声](/cv/ImageProcessing/03_xxx/01_noise1.jpg =360x)

![2.15 中值滤波 ksize=3 去椒盐噪声](/cv/ImageProcessing/03_xxx/13_noise1_3x3.jpg =360x)

</div>

1. 计算复杂度较高 ：对于每个像素，需对邻域像素进行排序，时间复杂度为，尤其是当图像较大时，计算量较大。
2. 对细节有一定影响：尽管中值滤波能有效去除噪声，但在处理较复杂的图像时，过度滤波可能会导致图像细节的损失。

### 2.6 双边滤波器

双边滤波（Bilateral Filtering）是一种非线性滤波方法（中值滤波也是），能够在平滑图像的同时保留图像的边缘信息。与传统的线性滤波方法（如均值滤波、高斯滤波）不同，双边滤波不仅考虑像素的空间邻近性，还考虑像素值的相似性，这使得它在处理图像细节和边缘时表现出色。

$$
I^{\prime}(x) = \frac{1}{W(x)} \sum_{x_i \in \Omega} I(x_i) \, f_s(\lVert x_i - x \rVert) \, f_r(\lvert I(x_i) - I(x) \rvert)
$$

1. ==归一化因子 $W(x)$==（保证权重和为 1）：

$$
W(x) = \sum_{x_i \in \Omega} f_s(\lVert x_i - x \rVert) \, f_r(\lvert I(x_i) - I(x) \rvert)
$$

2. ==邻域直径 $\Omega$==：以 x 为中心的邻域窗口。
3. ==空间核（spatial kernel）$f_s$==：一般取高斯函数，衡量像素位置距离。==$\sigma_s$ 控制空间平滑范围==（邻域大小）。直观理解的话像高斯滤波，越靠近中心的像素权重大。

$$
f_s(\|x_i - x\|) = \exp\!\left(-\frac{\|x_i - x\|^2}{2\sigma_s^2}\right)
$$

4. ==值域核（range kernel）$f_r$==：也是高斯函数，衡量像素值差异。==$\sigma_r$ 控制强度相似度==（保边缘能力）。直观理解像边缘检测，灰度值差别小的像素才会被纳入平均。

$$
f_r(|I(x_i) - I(x)|) = \exp\!\left(-\frac{|I(x_i) - I(x)|^2}{2\sigma_r^2}\right)
$$

双边滤波在平坦区域，和高斯滤波效果相似，能去噪；在边缘区域，因值域核限制，灰度差异大的像素不会相互影响，所以能够保留边缘。在 OpenCV 中使用 cv2.bilateralFilter() 函数实现双边滤波：

```py
dst = cv2.bilateralFilter(src, d, sigmaColor, sigmaSpace)
# 常用彩色图像参数组，如果噪声小，sigmaColor 可调低到 25~50
cv2.bilateralFilter(img, d=9, sigmaColor=75, sigmaSpace=75)
```

- **src：输入图像，8-bit 或 float32。**
- **d：邻域直径，对应公式里的 $\Omega$。手动指定的话，sigmaSpace 只控制权重衰减，不会扩大窗口。**
  - 如果 d <= 0，则由 sigmaSpace 自动计算：d = 2\*sigmaSpace+1。
- **sigmaColor：颜色空间的标准差，对应 $\sigma_r$。对于 8-bit 图像范围一般在 [10,100] 之间。**
  - 值大 → 去噪强，边缘模糊；值小 → 保边缘清晰，去噪弱
- **sigmaSpace：坐标空间的标准差，对应 $\sigma_s$。小图范围一般在 [1, 15]，大图范围一般为 [50,100]**
  - 值大 → 平滑范围大；值小 → 仅邻域内平滑，保边缘

双边滤波最适合处理平滑连续噪声（高斯噪声），对边缘保留友好；均值、斑点、量化有一定的作用，但是效果一般；对于椒盐噪声和泊松噪声，效果很差。

```py
import cv2

img_gaussian = cv2.imread('02_noise2.jpg')
img1 = cv2.bilateralFilter(img_gaussian, 9, 75, 75)

cv2.imshow('Gaussian Noise', img_gaussian)
cv2.imshow('Bilateral Filter on Gaussian Noise', img1)
cv2.waitKey(0)
```

<div class="layout">

![2.16 高斯噪声](/cv/ImageProcessing/03_xxx/02_noise2.jpg =360x)

![2.17 双边滤波去高斯噪声](/cv/ImageProcessing/03_xxx/14_denoise2.jpg =360x)

</div>

1. 计算量大：由于双边滤波需要计算每个像素与其邻域内其他像素的空间距离和像素值差异，因此其计算量较大，尤其是在高分辨率图像上，效率较低。
2. 参数调节困难 ：双边滤波有两个重要的参数：空间权重的标准差和像素值权重的标准差，需要根据图像的不同特性进行调节，调节不当可能会导致过度平滑或保留过多噪声。

## 3. 锐化与均衡化

### 2.2 锐化 (Sharpening)

2.2.1 原理
• 强化图像的边缘和细节
• 通过增强高频分量突出边缘

2.2.2 方法与算法
• 卷积锐化滤波器
• 拉普拉斯算子（Laplacian）
• 高提升滤波（High-Boost Filtering）
• 非线性锐化
• unsharp masking

2.2.3 作用
• 提升图像清晰度
• 强化边缘特征

2.2.4 应用
• 卫星图像增强
• 工业检测图像
• 摄影后期增强

### 2.3 均衡化 (Histogram Equalization)

2.3.1 原理
• 调整图像灰度分布，使直方图更均匀
• 提高图像对比度

2.3.2 方法与算法
• 全局直方图均衡化（Global HE）
• 自适应直方图均衡化（CLAHE）

2.3.3 作用
• 增强对比度
• 提升细节可见性

2.3.4 应用
• 医学图像增强（如 X 光片）
• 低光环境图像处理
• 工业检测、文档图像增强

### 2.4 去噪 (Denoising)

2.4.1 原理
• 消除图像噪声而尽量保留细节
• 去噪方法与噪声类型密切相关

2.4.2 方法与算法
• 空间域去噪（基于滤波）
• 均值/高斯/中值/双边滤波
• 变换域去噪
• 小波去噪
• 傅里叶去噪
• 深度学习方法
• DnCNN、U-Net 等

2.4.3 作用
• 减少噪声干扰
• 改善图像质量
• 提升后续图像处理效果

2.4.4 应用
• 摄像头图像去噪
• 医学影像预处理
• 图像修复与超分辨率
