---
title: 压缩与编码
date: 2025/09/03
categories:
  - 计算机视觉
tags:
  - OpenCV
  - 图像增强
  - 图像噪声
  - 滤波器
  - 傅里叶变换
---

## 2. 图像压缩

仍旧记得，在我刚开始写博客的时候，因为有很多图像需要插入网页，我就想做一个编写的批量压缩图像的小软件。但是那个时候，我 OpenCV 用不明白，只能用 Pillow 进行压缩操作。所以，我来弥补遗憾了！

当然了，并不是说 OpenCV 做压缩就一定更好，它只支持 JPG、PNG、BMP、WebP 等主流格式，而 Pillow 支持更多格式，包括 TIFF、GIF、ICO 等。对比 OpenCV 和 Pillow：

- 如果需要更高性能和复杂图像处理任务，比如物体检测或图像分割，选择 OpenCV。
- 如果主要是格式转换、批量处理或 Web 图片压缩，选择 Pillow 更轻便。

如果是高性能需求，可以在 OpenCV 中处理图像，再使用 Pillow 保存成其他格式或更进一步优化。

### 2.1 imwrite 中的压缩参数

```py
import cv2

image = cv2.imread('img_process_0/lena.png')

cv2.imwrite('img_process_0/compressed1.jpg', image, [cv2.IMWRITE_JPEG_QUALITY, 50])
cv2.imwrite('img_process_0/compressed2.png', image, [cv2.IMWRITE_PNG_COMPRESSION, 9])
cv2.imwrite('img_process_0/compressed3.webp', image, [cv2.IMWRITE_WEBP_QUALITY, 50])
```

- **IMWRITE_JPEG_QUALITY**：设置 JPEG 的压缩质量，范围为 0 - 100（默认值 95）。值越大，图像质量越高，压缩率越低，文件越大。值越小，图像质量下降，压缩率越高，文件越小。

- **IMWRITE_PNG_COMPRESSION**：设置 PNG 图像的压缩等级，0 - 9（默认值为 3）。值越大，压缩率越高，文件越小，但压缩速度越慢。值为 0 时不压缩，为 9 时压缩率最高但速度最慢。

- **IMWRITE_WEBP_QUALITY**：设置 WebP 图像的压缩质量，0 - 100（默认值为 75）。支持有损和无损压缩。值越大，质量越高，文件越大；值越小，质量越低，文件越小。

OpenCV 中，压缩相关的较全的图像格式，以及压缩参数，见下表：

| 格式 | 参数名称                               | 压缩类型  | 参数范围   | 默认值 |
| ---- | -------------------------------------- | --------- | ---------- | ------ |
| JPEG | cv2.IMWRITE_JPEG_QUALITY               | 有损压缩  | 0 - 100    | 95     |
| PNG  | cv2.IMWRITE_PNG_COMPRESSION            | 无损压缩  | 0 - 9      | 3      |
| WebP | cv2.IMWRITE_WEBP_QUALITY               | 有损/无损 | 0 - 100    | 75     |
| TIFF | cv2.IMWRITE_TIFF_COMPRESSION           | 无损/有损 | 1, 2, 3, 5 | 无     |
| PXM  | cv2.IMWRITE_PXM_BINARY                 | 无损      | 0 或 1     | 1      |
| EXR  | cv2.IMWRITE_EXR_TYPE                   | 无损压缩  | 0 - 5      | 无     |
| JP2  | cv2.IMWRITE_JPEG2000_COMPRESSION_X1000 | 有损压缩  | 0 - 1000   | 无     |

### 2.2 使用对象保存压缩数据

使用对象保存压缩数据，储存到内存缓冲区，可以用 imshow 读取，也可以进行网络传输。

```py
import cv2
import numpy as np

# 根据实际大小自动选择合适的单位
def format_size(size_bytes):
    if size_bytes < 1024:  # 小于 1KB
        return f"{size_bytes} B"
    elif size_bytes < 1024**2:  # 小于 1MB
        return f"{size_bytes / 1024:.2f} KB"
    else:  # 大于 1MB
        return f"{size_bytes / (1024**2):.4f} MB"

# 读取原始图像
image = cv2.imread('img_process_0/lena.png')

# 将图像压缩为 JPEG 格式并保存到内存缓冲区
encode_param = [cv2.IMWRITE_JPEG_QUALITY, 50]  # 设置压缩质量为50%
result, buffer = cv2.imencode('.jpg', image, encode_param)

# 确保编码成功
if result:
    byte_size = len(buffer)  # 获取字节大小
    print(f"Compressed size: {format_size(len(buffer))}")
else:
    print("Compression failed")

# 可以将 buffer 转换为字节流
# 用于 网络传输、数据库存储、实时处理（比如imdecode）
compressed_bytes = buffer.tobytes()

# 从压缩的字节数据中重新加载图像
compressed_image = cv2.imdecode(np.frombuffer(compressed_bytes, np.uint8), cv2.IMREAD_COLOR)

# 显示解码后的图像
cv2.imshow('Compressed Image', compressed_image)
cv2.waitKey(0)
```

**（1）result, buffer = cv2.imencode(ext, img, params=None)**

1. 返回值 result：布尔（bool）类型，表示编码是否成功。如果成功，返回 True，否则返回 False。
2. 返回值 buffer：numpy.ndarray 类型，表示编码后的二进制数据，存储在一个字节数组中，可以直接用于传输或写入文件。

- 参数 ext：文件扩展名（例如：.jpg, .png, .webp），确定使用哪种编码格式。
- 参数 img：输入的图像数据（通常为 numpy 数组类型）。
- 参数 params：编码参数列表，用于控制压缩质量或算法选项。

**（2）retval = cv2.imdecode(buf, flags)**

1. 返回值 retval：解码后的图像，类型为 numpy.ndarray。如果解码失败，返回 None。

- 参数 buf：numpy.ndarray 或 bytes 格式数据。
- 参数 flags：控制解码后的图像格式和颜色空间，常用值有：

| Flag                               | 用途                                                    | 使用频率 |
| ---------------------------------- | ------------------------------------------------------- | -------- |
| cv2.IMREAD_COLOR                   | 彩色图像解码（默认方式，无透明度）                      | 高       |
| cv2.IMREAD_GRAYSCALE               | 灰度图像解码                                            | 高       |
| cv2.IMREAD_UNCHANGED               | 保持原始图像格式，包括透明度                            | 较高     |
| cv2.IMREAD_ANYDEPTH                | 处理高精度位深度的图像，如 16 位或 32 位                | 中等     |
| cv2.IMREAD_REDUCED_COLOR_2/4/8     | 彩色图像按比例缩小，适合大图像加载优化（1/2，1/4，1/8） | 中等     |
| cv2.IMREAD_REDUCED_GRAYSCALE_2/4/8 | 彩色图像按比例缩小，适合大图像加载优化（1/2，1/4，1/8） | 中等     |

### 2.3 压缩算法简介

OpenCV 中 ==JPEG== 压缩算法的核心技术是：==DCT (离散余弦变换)==：

1. 将图像从空间域转换到频率域，通过抛弃高频信息（细节）来减少数据量。
2. 量化步骤会进一步降低精度并减少存储需求。
3. 使用熵编码（Huffman 编码）最终压缩数据。

OpenCV 中 ==PNG== 压缩算法的核心技术是：==DEFLATE 算法==：

1. 使用无损压缩，包括 LZ77 和哈夫曼编码的结合。
2. 数据不会丢失，但文件大小会更大。

OpenCV 中 ==WebP== 压缩算法的核心技术是：==预测编码 + 熵编码==：

1. 使用预测编码来减少冗余数据，然后使用 VP8 编码进一步压缩。
2. 支持有损和无损模式，适合现代网页和移动端应用。
