---
title: 08-视频流处理
date: 2025/10/10
categories:
  - OpenCV
tags:
  - 图像处理
  - 视频处理
---

## 1. 相机画面处理

捕捉实时的摄像头/相机画面是有很多实际应用的，比如日常生活中的车库停车的车牌识别、交通摄像头的违规车辆识别、远程考试的监控等等。

### 1.1 读取相机画面

在 OpenCV 中，使用 ==cv2.VideoCapture()== 函数来获取一个视频载体的对象，不管是图像序列、视频文件还是相机，都用它。它所必需的参数是 index_camera，表示要读取的相机的索引。如果有一个摄像头连接到计算机，它的索引为 0，如果有第二个，可以通过传递参数 1 的方式来选择它，依次类推。

```py
import cv2

capture = cv2.VideoCapture(0)
```

我们在实际运行的过程中，要检查连接是否正常啊，如果不正常也是需要返回信息给使用者的。==.isOpened()== 方法返回一个布尔值，如果可以建立连接，返回 True；如果不行，返回 False。我们可以通过这个方法做一个检测：

```py
if capture.isOpened() is False:
    print("Error opening the camera")
```

有了视频载体，也要有画面对吧？我记得上初中的时候老师说过，当人眼一秒钟看 24 张连续的图片的时候，它就是视频，因为我们分辨不出来。现在手机所说的高刷新率，比如苹果 17 的 120hz，就是一秒钟屏幕刷新的次数为 120 次。

我们把每一张图片叫做 1 帧画面，同样，在相机中捕获的视频流也是通过 **每一帧的画面** 进行读取的。通过 ==.read()== 方法从视频载体中获取帧画面，它同时还会返回一个布尔值，表示是否已从 capture 对象中正确的读取到帧。

```py
while capture.isOpened():
    # 因为是逐帧获取画面，所以需要用循环，不间断的获取
    ret, frame = capture.read()
    if ret is True:
        # 使用 imshow 显示捕获的帧画面
        cv2.imshow("real time vidio from camera", frame)
        # 对捕获的帧画面（图像）可以进行处理，比如转为灰度图
        gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        cv2.imshow("Grayscale vidio from camera", frame)
```

每 1 帧图像都可以对其处理，但需要注意的是，处理图像是需要消耗算力资源与时间的，越复杂消耗的时间越长，在实时的镜头中，比如腾讯会议，会出现卡顿、掉帧的情况，所以==在实时的视频流处理中，尽可能地选择轻量的处理方式==。

在 imshow() 的 GUI 中，我们可以直接点击关闭按钮退出程序。也可以自定义键盘事件来进行处理：

```py
    if ret is True:
        ......
        if cv2.waitKey(20) & 0xFF == ord("q"):
            break

# 释放视频载体对象，并销毁创建的窗口
capture.release()
cv2.destroyAllWindows()
```

### 1.2 扩展：自定义按键退出

==cv2.waitKey()== 是 OpenCV 用来等待键盘事件的函数。本质上咱直接写一个 cv2.waitKey(0)，随便按一下键盘，它就退出了。但是这样很容易出现问题，比如误触了，关键时刻就很难受。所以，我们来解析一下键盘事件的条件判断：

| 字符 | 十进制 ASCII | 十六进制 | 二进制（8 位） |
| ---- | ------------ | -------- | -------------- |
| 'q'  | 113          | 0x71     | 01110001       |

**ord('q')** 返回 q 字符对应的 8 位 ASCII 值，这个很好理解，就是上述表格的最后。但是 **cv2.waitKey()** 获取的 q 键的值，是随系统发生变化的：

| 操作系统 | "Q" 的十进制 ASCII | 十六进制 | 二进制（16 位）   |
| -------- | ------------------ | -------- | ----------------- |
| Windows  | 113                | 0x0071   | 00000000 01110001 |
| Linux    | 65393              | 0xFF71   | 11111111 01110001 |
| macOS    | 113                | 0x0071   | 00000000 01110001 |

可以看到，如果是在 Linux 系统上，直接进行条件判断，就会报错。我们需要通过和 0xFF 的按位与（&）操作，将 16 位键码，压缩成 8 位的 ASCII 码，它是怎么做的呢？：

```note
0xFF71 = 11111111 01110001
0x00FF = 00000000 11111111
---------------------------
结果 = 00000000 01110001 = 0x71 = 113
```

从计算可以看出，0xFF 的按位与，可以把高 8 位二进制数值消除掉，而低 8 位二进制最大为 256，键盘上没有什么值是比 256 更大的了，所以对于任何键盘值，我们都以用这种方式来自定义按键退出程序。

### 1.3 实时画面的属性

实时画面中的常见属性主要有三个，可以通过 get 方法获取属性，也可以通过 set 方法修改属性：

1. ==cv2.CAP_PROP_FRAME_WIDTH==：视频帧宽度
2. ==cv2.CAP_PROP_FRAME_HEIGHT==：视频帧高度
3. ==cv2.CAP_PROP_FPS==：视频帧率

```py
import cv2
capture = cv2.VideoCapture(0)

# 获取实时视频流属性
print("video width:".format(capture.get(cv2.CAP_PROP_FRAME_WIDTH)))
print("video height:".format(capture.get(cv2.CAP_PROP_FRAME_HEIGHT)))
print("video FPS:".format(capture.get(cv2.CAP_PROP_FPS)))

# 修改设置实时视频流属性
capture.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)
capture.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)
capture.set(cv2.CAP_PROP_FPS, 30)
```

一般情况下，高度和宽度都是可以修改的，但是帧率不一定，要看摄像头的说明。

### 1.4 手动计算帧率

影响帧率的三个主要因素有 **分辨率、接口带宽、曝光与光照**：

- 分辨率越高，帧率越低（因为带宽和传输限制）。比如 640×480 可达 60 FPS，但 1920×1080 常为 30 FPS。
- USB 2.0 通常限制在 30 FPS@1080p 左右，USB 3.0 才能上 60 FPS。网络摄像头则受网速与编码影响。
- 弱光条件下，摄像头会自动延长曝光时间，从而降低实际帧率（比如夜晚时从 30 FPS 掉到 15 FPS）。

一般来说 FPS 都是越高越好，但是，算法每秒应处理的帧数取决于需要解决的特定问题。例如，如果算法需要跟踪和检测在街上游走的行人，那么 15 FPS 可能就足够了；如果是检测和跟踪高速公路上快速行驶的汽车，可能需要 20~30 FPS。

我们已经知道，很多摄像头不一定是固定的 FPS，它会随着一些因素变化，比如弱光条件，所以有的时候我们也需要手动计算 FPS：

```py
import time

while capture.isOpened():
    ret, frame = capture.read()
    if ret is True:
        processing_start = time.time()  # 处理开始事件
        cv2.imshow("Input frame from camera", frame)

        processing_end = time.time()  # 处理结束事件
        precessing_time = processing_end - processing_start
        print(f"FPS: {1.0 / precessing_time}")  # 计算帧率并打印

        if cv2.waitKey(10) & 0xFF == ord("q"):
            break
```

### 1.5 扩展：摄像头帧率分布

常见的各类摄像头帧率范围总览：

| 摄像头类型                       | 常见分辨率      | 典型帧率（FPS）              | 说明                                                                                |
| -------------------------------- | --------------- | ---------------------------- | ----------------------------------------------------------------------------------- |
| 💻 **笔记本内置摄像头**          | 720p / 1080p    | **15–30 FPS**                | 主要为视频会议设计，通常固定 30 FPS。部分低端型号甚至 15 FPS。                      |
| 🔌 **普通 USB 摄像头**           | 720p / 1080p    | **15–60 FPS**                | 普通网络摄像头（如罗技 C270、C920）在低分辨率下可达 60 FPS，高分辨率时多为 30 FPS。 |
| 📹 **安防/监控摄像头（IPC）**    | 1080p / 2K / 4K | **20–30 FPS**（有时 15 FPS） | 追求稳定与存储节约，通常锁定 25–30 FPS。夜视模式下可能降到 15 FPS。                 |
| 📱 **手机前/后置摄像头**         | 1080p / 4K      | **30–60 FPS**（视频模式）    | 视频拍摄通常 30 FPS 或 60 FPS。部分高端机支持 120/240 FPS 慢动作模式。              |
| 📷 **数码相机 / 无反相机**       | 1080p / 4K      | **24–120 FPS**               | 可调节帧率以匹配影视标准（24/30/60 FPS 等）。                                       |
| 🎮 **游戏摄像头 / 高速运动捕捉** | 720p / 1080p    | **60–240 FPS**               | 用于动作捕捉或手势识别。                                                            |
| ⚙️ **工业相机（机器视觉）**      | VGA ～ 2K       | **30–240 FPS**               | 高速检测用途，可达数百帧，但分辨率较低时才行。                                      |

### 1.6 保存帧画面与视频

如果说，我们遇到了一些感兴趣的画面，并且想记录为图像的形式，我们可以通过 ==cv2.imwrite()== 方法来写入文件。比如这里，我们用 q 表示退出，用 c 表示截取画面：

```py
frame_index = 0
while capture.isOpened():
    ret, frame = capture.read()
    if ret is True:
        if cv2.waitKey(20) & 0xFF == ord("c"):
            frame_name = f"camera_frame_{frame_index}.png"
            cv2.imwrite(frame_name, frame)
            frame_index += 1

        if cv2.waitKey(20) & 0xFF == ord("q"):
            break
```

那么如果我们想保存成视频呢？不要着急，==cv2.VideoWriter()== 方法可以在本地直接写入视频文件。

```py
import cv2

capture = cv2.VideoCapture(0) # 打开摄像头
fourcc = cv2.VideoWriter_fourcc(*'XVID')  # 定义编码器（FourCC）
# out = cv2.VideoWriter('output.avi', fourcc, fps, (frame_width, frame_height))
out = None
recording = False
index = 0

print("按 C 开始/停止录制：按 'q' 退出实时画面捕捉")
while capture.isOpened():
    ret, frame = capture.read()
    if not ret:
        break
    cv2.imshow('Camera', frame)
    key = cv2.waitKey(20) & 0xFF

    if key == ord("c"):
        if not recording:
            out = cv2.VideoWriter(f'output_{index}.avi', fourcc, 30.0,
                                    (frame.shape[1], frame.shape[0]))
            recording = True
            print("🎥 开始录制...")
        else:
            recording = False
            out.release()
            print(f"⏹ 暂停录制，视频已保存为 output_{index}.avi")
        index += 1
    elif key == ord('q'):
        if recording:
            out.release()
            print(f"录制结束，视频已保存为 output_{index}.avi")
        print("🖥️ 退出实时监控")
        break

    # 如果正在录制，则保存当前帧
    if recording and out is not None:
        out.write(frame)

# 释放资源
capture.release()
cv2.destroyAllWindows()
```

### 1.7 扩展：视频编码器与格式

- ==FourCC（Four Character Code）==：即四字符编码器标识符，表示采用哪种视频编码算法（压缩方式）。例如：XVID, MJPG, H264, mp4v。
- ==文件后缀（容器格式）==：表示视频文件的封装格式（容器），例如 .avi、.mp4、.mov。容器负责存放压缩视频流、音频流、时间戳等元数据。

虽然 FourCC 编码器 与 封装格式 并不相同，但两者必须 “兼容” 才能正常播放。常见 FourCC 与文件格式对应表：

| FourCC（编码器）    | 推荐文件后缀（容器） | 压缩特性                                                | 播放兼容性                 |
| ------------------- | -------------------- | ------------------------------------------------------- | -------------------------- |
| `'XVID'`            | `.avi`               | MPEG-4 Part 2 编码，压缩好，兼容性强（OpenCV 默认推荐） | ✅ Windows / VLC / OpenCV  |
| `'DIVX'`            | `.avi`               | 类似 XVID                                               | ✅                         |
| `'MJPG'`            | `.avi` / `.mjpg`     | Motion JPEG（逐帧压缩）                                 | ✅ 快速但文件较大          |
| `'mp4v'`            | `.mp4` / `.avi`      | MPEG-4 编码，较现代                                     | ✅ 推荐一般用途            |
| `'H264'` / `'X264'` | `.mp4` / `.mov`      | H.264 编码，压缩高效                                    | ⚠️ 需要系统安装 H.264 支持 |
| `'avc1'`            | `.mp4`               | H.264 的另一种标识                                      | ✅                         |
| `'WMV1'` / `'WMV2'` | `.avi` / `.wmv`      | Windows Media Video                                     | ⚠️ 仅 Windows 播放器兼容   |
| `'IYUV'` / `'YUYV'` | `.avi`               | 原始 YUV 格式（未压缩）                                 | ⚙️ 文件极大，调试用        |

### 1.8 读取 IP 摄像机

IP 摄像机其实就是网络摄像机，它的本质是：把摄像头 + 编码器 + 网络模块集成在一起，可以通过 IP 网络（局域网或互联网） 直接传输视频流的摄像头。实际的使用场景有：

- 家庭智能监控：手机随时查看家中画面
- 商铺 / 公司安防：通过 NVR 管理多个 IP 摄像机
- 工业 / 交通监控：远程监控生产线或路口
- 智慧城市：智能分析、视频流接入大数据平台

我们可以拿一些 **合法且常见的“公开”摄像头** 来练手：

- [EarthCam — 大量城市地标、港口、景点的公开摄像头（面向公众）。](https://www.earthcam.com/)
- [Explore.org — 大量自然/野生动物直播（熊、海狮、熊钓鱼等），面向公众。](https://explore.org/)
- [各州 / 各国的交通管理局（State DOT）发布的路况摄像头 / 交通摄像头（通常网页列出并允许公众查看）。示例：Nevada DOT、WSDOT 等。](https://www.dot.nv.gov/travel-info/road-conditions/traffic-cameras)
- [FAA / 气象机构或国家公园等托管的气象/景观摄像头（用于公共服务 / 教育）。](https://weathercams.faa.gov/map/-179.30371,23.35029,-56.69629,71.75605)

## 2. 视频文件处理

### 2.1 读取视频文件

==cv2.VideoCapture()== 方法不仅可以打开本地摄像头，网络摄像头，也可以读取视频文件。这时候它的参数就不是数值了，而是视频文件的路径。

```py
video_path = ""
capture = cv2.VideoCapture(video_path)
```

后续的操作，不管是用 imshow 显示出来，还是进行处理操作，跟之前都是一样的。那么，我们可以根据已经学过的知识，封装一个简易的视频播放的函数：

```py
import cv2

def play_video(video_path):
    cap = cv2.VideoCapture(video_path)
    if cap.isOpened() is False:
        print(f"无法打开视频文件: {video_path}")
        return False

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        cv2.imshow("Video", frame)
        key = cv2.waitKey(25) & 0xFF

        # 多种退出方式
        if key in [ord('q'), ord('Q'), 27]:
            print("Q / ESC 键被按下，退出循环")
            break
        elif key == ord(' '):
            print("空格键被按下，暂停播放")
            while True:
                key2 = cv2.waitKey(0) & 0xFF
                if key2 == ord(' '):
                    break
                elif key2 == ord('q') or key2 == 27:
                    cap.release()
                    cv2.destroyAllWindows()
                    exit()

        # 检查窗口是否还存在，要注意：窗口名称一定要一致，这里是 Video
        if cv2.getWindowProperty("Video", cv2.WND_PROP_VISIBLE) < 1:
            print("用户点击了关闭按钮(X)")
            break

    cap.release()
    cv2.destroyAllWindows()
    return True


path = "D:\CodeReproduction\ReLayer\\frxxz_hanlijieyin.mp4"
if play_video(path):
    print("播放完成")
else:
    print("播放失败")
```

==cv2.getWindowProperty()== 函数的作用是**获取指定窗口的属性值**，有两个参数，1 是窗口名称，2 是获取的属性 ID。==cv2.WND_PROP_VISIBLE== 有三个值，1 表示窗口可见（存在），0 表示窗口不可见（已被关闭），-1 表示窗口不存在。

![2.1 OpenCV 读取视频文件 - 韩立结婴](/cv/ImageProcessing/07_xxx/01_video1.png =560x)

### 2.2 视频属性详解

在 1.3 小节，我们讲了视频流文件的**通用基础属性**：帧的宽度、帧的高度、帧率。在 1.7 的扩展中，还讲了**编解码器与格式**：FourCC。在这里我们主要讲解**视频文件的特定属性**：

- ==cv2.CAP_PROP_POS_MSEC==：当前时间戳（毫秒）。表示视频流的当前位置（从开始算起的时间）。常用于视频文件的精确跳转和进度显示。
- ==cv2.CAP_PROP_POS_FRAMES==：当前帧的索引（从 0 开始）。表示下一帧将被解码的帧序号。用于获取当前位置或跳转到指定帧。
- ==cv2.CAP_PROP_POS_AVI_RATIO==：视频文件的相对位置（0.0 到 1.0）。表示当前位置在总时长中的比例。用于实现进度条。
- ==cv2.CAP_PROP_FRAME_COUNT==：视频文件的总帧数。结合 CAP_PROP_POS_FRAMES 可以计算播放进度。

来做一个简单的小实验，反向播放视频。我们知道 **CAP_PROP_POS_FRAMES** 表示播放时的帧索引，而 **CAP_PROP_FRAME_COUNT** 表示总帧数，那我们就可以通过这两个参数，来实现视频的反向播放。

```py
import cv2

def play_video(video_path):
    cap = cv2.VideoCapture(video_path)
    if cap.isOpened() is False:
        print(f"无法打开视频文件: {video_path}")
        return False

    # 从总帧数获取逆序的帧索引
    frame_index = cap.get(cv2.CAP_PROP_FRAME_COUNT) - 1

    # 循环条件需要加一个 frame_index >= 0
    while cap.isOpened() and frame_index >= 0:
        # 设定视频流下一帧读取的帧索引，实现倒放视频
        cap.set(cv2.CAP_PROP_POS_FRAMES, frame_index)
        ret, frame = cap.read()
        if not ret:
            break

        cv2.imshow("Video Backwards", frame)
        frame_index -= 1
        key = cv2.waitKey(25) & 0xFF

        if key in [ord('q'), ord('Q'), 27]:
            print("Q / ESC 键被按下，退出循环")
            break
        elif key == ord(' '):
            print("空格键被按下，暂停播放")
            while True:
                key2 = cv2.waitKey(0) & 0xFF
                if key2 == ord(' '):
                    break
                elif key2 == ord('q') or key2 == 27:
                    cap.release()
                    cv2.destroyAllWindows()
                    exit()

        # 检查窗口是否还存在，要注意：窗口名称一定要一致，这里是 Video
        if cv2.getWindowProperty("Video Backwards", cv2.WND_PROP_VISIBLE) < 1:
            print("用户点击了关闭按钮(X)")
            break

    cap.release()
    cv2.destroyAllWindows()
    return True


path = "D:\CodeReproduction\ReLayer\\frxxz_hanlijieyin.mp4"
if play_video(path):
    print("播放完成")
else:
    print("播放失败")
```

![2.2 OpenCV 倒放视频文件 - 韩立结婴](/cv/ImageProcessing/07_xxx/01_video2.png =560x)

### 2.3 扩展：剩余全部属性

**图像质量与处理：摄像头通用属性 1，归一化参数，取值范围为 [0, 1]**：

1. ==cv2.CAP_PROP_BRIGHTNESS==：亮度。0.0=最暗, 0.5=默认, 1.0=最亮。
2. ==cv2.CAP_PROP_CONTRAST==：对比度。0.0=最低对比度, 1.0=最高对比度。
3. ==cv2.CAP_PROP_SATURATION==：饱和度。0.0=黑白, 1.0=最大饱和度。
4. ==cv2.CAP_PROP_HUE==：色调。0.0=默认色调, 调整色彩相位。
5. ==cv2.CAP_PROP_GAIN==：增益。0.0=无增益, 值越大图像越亮但噪点可能越多。
6. ==cv2.CAP_PROP_SHARPNESS==：锐度。调整图像边缘的锐利程度。0.0=最柔和, 1.0=最锐利。
7. ==cv2.CAP_PROP_GAMMA==：伽马校正。通常 1.0=线性, 其他值进行伽马校正。
8. ==cv2.CAP_PROP_BACKLIGHT==：背光补偿。0.0=关闭, 1.0=最强背光补偿。

**图像质量与处理：摄像头通用属性 2，特殊取值范围参数**：

1. **cv2.CAP_PROP_EXPOSURE**：曝光。调整摄像头的曝光值，取值范围复杂，不同牌子不一样。
2. **cv2.CAP_PROP_TEMPERATURE**：白平衡（色温）。实际色温值，如 2800（暖光）到 6500（冷光）开尔文。
3. **cv2.CAP_PROP_WHITE_BALANCE_BLUE_U**：白平衡蓝色分量。归一化值或实际值，取决于驱动。
4. **cv2.CAP_PROP_AUTO_WB**：自动白平衡。设置为 1 开启自动白平衡，0 则关闭。
5. **cv2.CAP_PROP_AUTO_EXPOSURE**：自动曝光。在很多后端中，与自动白平衡共享同一个属性 ID。通常通过 cv2.CAP_PROP_EXPOSURE 的值来判断（如设置为某个特定值代表自动模式）。

**图像质量与处理：云台摄像头专有属性**：

1. cv2.CAP_PROP_PAN：平移（水平方向）。用于云台摄像头。
2. cv2.CAP_PROP_TILT：倾斜（垂直方向）。用于云台摄像头。
3. cv2.CAP_PROP_ROLL：旋转。用于云台摄像头。

**其他与后端相关的属性**：

1. ==cv2.CAP_PROP_BUFFERSIZE==：内部缓冲区的帧数。设置此值可以控制延迟，但并非所有后端都支持。
2. cv2.CAP_PROP_MODE：表示当前视频流模式的后端特定值。
3. cv2.CAP_PROP_CONVERT_RGB：布尔标志，指示是否应将帧转换为 RGB。通常为 True。
4. cv2.CAP_PROP_ISO_SPEED：ISO 感光度。用于调整摄像头传感器对光的敏感度。
5. cv2.CAP_PROP_ZOOM：变焦。用于控制摄像头的数字或光学变焦。
6. cv2.CAP_PROP_FOCUS：焦距。调整摄像头的对焦距离。
