---
title: 05-形态学与运算
date: 2025/10/16
categories:
  - OpenCV
tags:
  - 图像处理
  - 形态学与运算
---

## 1. 运算类操作

### 1.1 饱和运算

饱和运算的原理十分简单，比如我们正常 RGB 的像素范围在 [0, 255] 之间，但是有的时候，做了加法、减法等等，导致其越界了。怎么办呢？**OpenCV 的处理方式**：会直接将值截断在边界值，小于 0 的被置为 0，大于 255 的被置为 255。

所以 ==饱和运算（Saturated Operation）== 在实现上就是通过最大值与最小值将运算限制在固定范围之内。我们先用 Python 的方法来做一个演示，通过 min 和 max 函数来截断：

```py
def opencv_add1(a, b):
    temp = a + b
    return min(max(temp, 0), 255)

opencv1 = opencv_add1(250, 50)
print("opencv add 1: ", opencv1)  # 255
```

但需要注意的是，OpenCV 的底层是 Numpy 数组，所以如果真实的要去做操作，需要使用 ==np.clip()== 函数进行截断，或者直接使用 where 条件判断也可以：

```py
def opencv_add2(a, b):
    # 1. 先将输入转换为更大的整数类型（比如 int32），防止中间计算溢出
    img1_int32 = a.astype(np.int32)
    img2_int32 = b.astype(np.int32)

    # 2. 使用 clip 函数手动饱和处理，裁剪到 [0, 255] 范围
    result_int32 = img1_int32 + img2_int32
    result_clipped = np.clip(result_int32, 0, 255)

    # 3. 最后再转换回 uint8 返回
    return result_clipped.astype(np.uint8)

opencv2 = numpy_add(np.uint8([[250]]),  np.uint8([[50]]))
print("opencv add 2: ", opencv2)

```

此外，np.uint8 在内存中占用 1 个字节（8 位），只能表示 0 到 255 这 256 个整数，在溢出后它的默认规撞上了 C 语言层面的整数溢出规则，也就是进行回绕的**模运算**：把 0 和 255 收尾相连，形成一个圆形环路。

```py
import numpy as np
import cv2

x = np.uint8([[250]])
y = np.uint8([[50]])

opencv = cv2.add(x, y)  # 250 + 50 = 300 -> 255
numpy = x + y  # 250 + 50 = 300 -> 44 (mod 256)

print("opencv:\n", opencv)  # 饱和运算
print("numpy:\n", numpy)  # 模运算
```

在我的例子中就是 mod 256。这种 Numpy 的模运算，和 OpenCV 的饱和运算是两码事儿，不要混淆了。

### 1.2 图像加减法

图像的加减法分别使用 ==cv2.add()==、==cv2.subtract()== 两个函数执行，如果读取的内容是图像，它们在内部会自动执行饱和运算。当然，从实现上来说，这两个函数不仅可以用于数组的逐元素运算，也可以对标量运算。

```py
import cv2
import numpy as np
import matplotlib.pyplot as plt

def show_img_by_plt(img, title, pos):
    ax = plt.subplot(1, 3, pos)
    plt.imshow(img)
    plt.title(title)
    plt.axis('off')

img = cv2.imread('01_luna.png', 1)  # 读取图像
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
M = np.ones(img.shape, dtype="uint8") * 255

result1 = cv2.add(img, M)
result2 = cv2.subtract(img, M)

plt.figure(figsize=(14, 8))
show_img_by_plt(img, "Original Image", 1)
show_img_by_plt(result1, "Add 255", 2)
show_img_by_plt(result2, "Subtract 255", 3)
plt.show()
```

![1.1 图像加减法越界结果](/cv/ImageProcessing/05_xxx/01_addsub1.png)

![1.2 图像加减法正常结果](/cv/ImageProcessing/05_xxx/02_addsub2.png)

### 1.3 图像混合

图像混合也是图像相加的一种，只不过可以赋予不同图像不同的权重进行相加。没错，就是我们的老朋友 ==cv2.addWeighted()== 函数，在《锐化与均衡化》中已经见过面了：

```py
dst = cv2.addWeighted(src1, alpha, src2, beta, gamma)
```

$$
dst(x,y)=src1(x,y)\cdot{\alpha}+src2(x,y)\cdot{\beta}+\gamma
$$

那我们就再来一个老熟人 ==Sobel 算子==，看一下 X 方向、Y 方向、XY 混合方向，边缘检测的结果分别是什么：

```py
import cv2
import matplotlib.pyplot as plt

def show_img_by_plt(img, title, pos):
    ax = plt.subplot(1, 3, pos)
    plt.imshow(img, cmap="gray")
    plt.title(title)
    plt.axis('off')

img = cv2.imread('01_luna.png', 0)  # 读取图像
gradient_x = cv2.Sobel(img, cv2.CV_32F, 1, 0, 3)
gradient_y = cv2.Sobel(img, cv2.CV_32F, 0, 1, 3)
gradient_xy = cv2.magnitude(gradient_x, gradient_y)

plt.figure(figsize=(14, 8))
show_img_by_plt(gradient_x, "Gradient X Float32", 1)
show_img_by_plt(gradient_y, "Gradient Y Float32", 2)
show_img_by_plt(gradient_xy, "Gradient XY Float32", 3)
plt.show()

plt.figure(figsize=(14, 8))
show_img_by_plt(cv2.convertScaleAbs(gradient_x), "Gradient X uint8", 1)
show_img_by_plt(cv2.convertScaleAbs(gradient_y), "Gradient Y uint8", 2)
show_img_by_plt(cv2.convertScaleAbs(gradient_xy), "Gradient XY uint8", 3)
plt.show()
```

![1.3 Sobel 算子 - 不同方向的梯度显示 浮点数](/cv/ImageProcessing/05_xxx/03_max1.png)

![1.4 Sobel 算子 - 不同方向的梯度显示 正整数](/cv/ImageProcessing/05_xxx/04_max2.png)

### 1.4 按位运算

在 OpenCV 中，按位运算的函数一共有四个：**与（and）、或（or）、非（not）、异或（xor）**，每一个都很常用：

```py
cv2.bitwise_and(src1, src2, dst=dst, mask=mask)
cv2.bitwise_or(src1, src2, dst=dst, mask=mask)
cv2.bitwise_xor(src1, src2, dst=dst, mask=mask)

cv2.bitwise_not(src, mask=mask)
```

可选参数 **dst** 用来指定输出的目标数组，通常在优化内存或者高性能储存时使用；可选参数 **mask** 用来指定按位运算的区域，黑白二值图像，黑色部分代表不处理的区域，白色部分代表需要做按位运算的区域。

1. **按位与**：两个像素同时为“真”时，结果才为“真”。**常用于** 提取 ROI（感兴趣区域）。用一个掩膜（mask）与原图进行与操作，可以抠出掩膜区域的图像。

![1.5 按位与运算 AND](/cv/ImageProcessing/05_xxx/05_and.png)

2. **按位非**：反转每一位，即“求反”或“取补”。**常用于** 反转掩膜、生成负片。

![1.6 按位非运算 AND](/cv/ImageProcessing/05_xxx/05_not.png)

3. **按位或**：两个像素中任意一个为“真”时，结果就为“真”。**常用于** 合并图像或区域。

![1.7 按位或运算 OR](/cv/ImageProcessing/05_xxx/05_or.png)

4. **按位异或**：两个像素值不同时，结果为“真”；相同时，结果为“假”。**常用于** 找不同（检测区域变化）、绘制对称图形、加密/解密。

假设有一家公司的仓库进小偷了，但是一时间不知道被偷了什么东西，不过幸好仓库的摄像头全程开启，所以我们通过前后不同时间的对比，找到了什么东西被拿走了（就是小孩子玩的找不同）。

直接减图会得到有正有负的差异，不方便处理。而 XOR 只关心“是否不同”，不关心谁亮谁暗，结果更二值化，便于后续分析。

![1.8 按位异或运算 XOR](/cv/ImageProcessing/05_xxx/05_xor.png)

这里之所以有重影是因为我截图的时候，有些许误差，人眼不好分辨。不过很明显，五处不同颜色很鲜艳，误差的重影就只有轮廓。

:::: code-group
::: code-group-item 按位与 AND

```py
import cv2
import numpy as np
import matplotlib.pyplot as plt

def show_img_by_plt(img, title, pos):
    ax = plt.subplot(1, 3, pos)
    plt.imshow(img)
    plt.title(title)
    plt.axis('off')

img1 = cv2.imread('04_cafe.jpg', 1)
img2 = np.zeros((1280, 1280, 3), dtype=np.uint8)
cv2.circle(img2, (960, 700), 280, (255, 255, 255), -1)
bitwise_and = cv2.bitwise_and(img1, img2)

plt.figure(figsize=(14, 8))
show_img_by_plt(cv2.cvtColor(img1, cv2.COLOR_BGR2RGB), "Original Image", 1)
show_img_by_plt(cv2.cvtColor(img2, cv2.COLOR_BGR2RGB), "Comparsion Image", 2)
show_img_by_plt(cv2.cvtColor(bitwise_and, cv2.COLOR_BGR2RGB), "AND Result", 3)
plt.show()
```

:::
::: code-group-item 按位非 NOT

```py
import cv2
import numpy as np
import matplotlib.pyplot as plt

def show_img_by_plt(img, title, pos):
    ax = plt.subplot(1, 3, pos)
    plt.imshow(img)
    plt.title(title)
    plt.axis('off')

img1 = cv2.imread('04_cafe.jpg', 1)
img2 = np.zeros((1280, 1280, 3), dtype=np.uint8)
cv2.circle(img2, (960, 700), 280, (255, 255, 255), -1)
bitwise_not = cv2.bitwise_not(img2)
bitwise_and = cv2.bitwise_and(img1, bitwise_not)

plt.figure(figsize=(14, 8))
show_img_by_plt(cv2.cvtColor(img1, cv2.COLOR_BGR2RGB), "Original Image", 1)
show_img_by_plt(cv2.cvtColor(bitwise_not, cv2.COLOR_BGR2RGB), "NOT Result", 2)
show_img_by_plt(cv2.cvtColor(bitwise_and, cv2.COLOR_BGR2RGB), "AND Result", 3)
plt.show()
```

:::
::: code-group-item 按位或 OR

```py
import cv2
import numpy as np
import matplotlib.pyplot as plt

def show_img_by_plt(img, title, pos):
    ax = plt.subplot(2, 3, pos)
    plt.imshow(img)
    plt.title(title)
    plt.axis('off')

img1 = cv2.imread('04_cafe.jpg', 1)
img2 = np.zeros((1280, 1280, 3), dtype=np.uint8)
cv2.circle(img2, (960, 700), 280, (255, 255, 255), -1)
img3 = np.zeros((1280, 1280, 3), dtype=np.uint8)
cv2.circle(img3, (500, 460), 320, (255, 255, 255), -1)
bitwist_or = cv2.bitwise_or(img2, img3)
bitwise_and = cv2.bitwise_and(img1, bitwist_or)

plt.figure(figsize=(14, 8))
show_img_by_plt(cv2.cvtColor(img1, cv2.COLOR_BGR2RGB), "Original Image", 1)
show_img_by_plt(cv2.cvtColor(img2, cv2.COLOR_BGR2RGB), "Original Image", 2)
show_img_by_plt(cv2.cvtColor(img3, cv2.COLOR_BGR2RGB), "Original Image", 3)
show_img_by_plt(cv2.cvtColor(bitwist_or, cv2.COLOR_BGR2RGB), "NOT Result", 5)
show_img_by_plt(cv2.cvtColor(bitwise_and, cv2.COLOR_BGR2RGB), "AND Result", 6)
plt.show()
```

:::
::: code-group-item 按位异或 XOR

```py
import cv2
import matplotlib.pyplot as plt

def show_img_by_plt(img, title, pos):
    ax = plt.subplot(1, 3, pos)
    plt.imshow(img)
    plt.title(title)
    plt.axis('off')

img1 = cv2.imread('03_zbt1.jpg', 1)
img2 = cv2.imread('03_zbt2.jpg', 1)
bitwise_xor = cv2.bitwise_xor(img1, img2)

plt.figure(figsize=(14, 8))
show_img_by_plt(cv2.cvtColor(img1, cv2.COLOR_BGR2RGB), "Original Image", 1)
show_img_by_plt(cv2.cvtColor(img2, cv2.COLOR_BGR2RGB), "Comparsion Image", 2)
show_img_by_plt(cv2.cvtColor(bitwise_xor, cv2.COLOR_BGR2RGB), "XOR Result", 3)
plt.show()
```

:::
::::

## 2. 形态学操作

形态学运算是一种基于形状的图像处理技术，它是通过结构元素与图像进行特定运算的方式来改变图像的形态和特征。结构元素是一种小型、预定义的形状，通常是矩形、圆形或者椭圆形，可以与图像中的像素进行匹配。在图像处理中应用广泛，特别是在图像分割、边缘检测、文本识别、计算机视觉等领域中。

形态学运算包括膨胀、腐蚀、开运算、闭运算等。其中膨胀操作可以将图像中的物体变大，使它更加连通；腐蚀操作则可以将图像中的物体变小，使它更加细化；开运算可以去除噪声，平滑图像的边缘；闭运算可以填补图像中物体的孔洞。

### 2.1 膨胀与腐蚀

==膨胀（dilate）== 通常用于 **填补空洞**，物体内部的小孔洞会被填充；**连接断线**，断裂的线条会被连接起来；**边缘扩张**，让物体的边缘向外扩展。

==腐蚀（erode）== 通常用于 **去除小噪点**，细小的白色噪点会被完全腐蚀掉；**分离粘连物体**，轻微腐蚀可以让轻微粘连的物体分开；**边缘细化**，让物体的边缘向内收缩。

但也需要注意，过度腐蚀可能会导致 “有用的物体会变小甚至消失”，“纤细的特征（如文字笔画）可能被腐蚀断”，所以要谨慎处理，尤其是要谨慎选择迭代次数。

```py
cv2.dilate(src, kernel, dst=None, anchor=(-1, -1), iterations=1, borderType=cv2.BORDER_CONSTANT, borderValue=0)
cv2.erode(src, kernel, dst=None, anchor=(-1, -1), iterations=1, borderType=cv2.BORDER_CONSTANT, borderValue=0)
```

必须的参数有 2 个，可选参数中有 1 个比较常用：

- **src 输入图像**：想要处理的原始图片。
- **kernel 结构元素（核）**：形态学操作的"刷子"。默认矩形的话，可以直接用 np 生成一个数组。
- **iterations 迭代次数（重要可选）**：执行腐蚀/膨胀的次数，默认=1。

不怎么重要，通常可以省略的可选参数：**dst** 输出的目标，按位操作中也有。**anchor** 核的锚点位置，默认=(-1, -1)，表示核的中心，几乎永远不需要改。**borderType**、**borderValue** 边界类型与边界值。

![2.1 Sobel 算子 - 腐蚀与膨胀](/cv/ImageProcessing/05_xxx/06_ed1.png)

腐蚀是**用核内最小值替换中心像素**，所以它更偏爱黑色，如果绝大部分都是黑色，会把白色都消灭掉。而膨胀是**用核内最大值替换中心像素**，所以他更偏爱白色，消灭黑色会让区域变得更白。

诶！有点意思，所以如果是黑色背景的白色噪声，腐蚀可以消除，但是反过来如果白色背景里有黑色噪声，腐蚀反而会增大噪声？我们来试试看：

![2.2 腐蚀性质的探究](/cv/ImageProcessing/05_xxx/06_ed2.png)

:::: code-group
::: code-group-item Sobel 算子的腐蚀与膨胀

```py
import cv2
import numpy as np
import matplotlib.pyplot as plt

def show_img_by_plt(img, title, pos):
    ax = plt.subplot(1, 3, pos)
    plt.imshow(img, cmap="gray")
    plt.title(title)
    plt.axis('off')

img = cv2.imread('01_luna.png', 0)  # 读取图像
gradient_x = cv2.Sobel(img, cv2.CV_32F, 1, 0, 3)
gradient_y = cv2.Sobel(img, cv2.CV_32F, 0, 1, 3)
gradient_xy = cv2.convertScaleAbs(cv2.magnitude(gradient_x, gradient_y))

kernel = np.ones((3,3), np.uint8)  # 创建一个3x3的矩形结构元素
eroded = cv2.erode(gradient_xy, kernel)
dilated = cv2.dilate(gradient_xy, kernel)

plt.figure(figsize=(14, 8))
show_img_by_plt(gradient_xy, "Sobel XY uint8", 1)
show_img_by_plt(eroded, "Eroded", 2)
show_img_by_plt(dilated, "Dilated", 3)
plt.show()
```

:::
::: code-group-item 腐蚀性质的探究

```py
import cv2
import numpy as np
import matplotlib.pyplot as plt

def show_img_by_plt(img, title, pos):
    ax = plt.subplot(1, 4, pos)
    plt.imshow(img, cmap="gray")
    plt.title(title)
    plt.axis('off')

img1 = np.zeros((512, 512), dtype=np.uint8)
img2 = np.ones((512, 512), dtype=np.uint8)

# img1 添加盐噪声（白点），img2 添加胡椒噪声（黑点）
salt_coords = np.random.randint(0, 512, (500, 2))
img1[salt_coords[:,0], salt_coords[:,1]] = 255
pepper_coords = np.random.randint(0, 512, (500, 2))
img2[pepper_coords[:,0], pepper_coords[:,1]] = 0

kernel = np.ones((3,3), np.uint8)  # 创建一个3x3的矩形结构元素
eroded1 = cv2.erode(img1, kernel)
eroded2 = cv2.erode(img2, kernel)

plt.figure(figsize=(14, 8), facecolor='lightblue')
show_img_by_plt(img1, "Black Image", 1)
show_img_by_plt(eroded1, "Eroded", 2)
show_img_by_plt(img2, "White Image", 3)
show_img_by_plt(eroded2, "Eroded", 4)
plt.show()
```

:::
::::

### 2.2 形态学的刀与刀法

腐蚀与膨胀是形态学的基本操作，所以提供了函数接口 erode() 和 dilate()，用于执行单一的操作。==getStructuringElement()== 是 **工具函数**，用于创建形态学操作所需的“刷子”（结构元素）。==morphologyEx()== 是**高级函数**，它在内部调用基础函数，来实现更复杂的形态学操作。简单比喻：

- getStructuringElement() 像是 **造一把刀**
- erode() / dilate() 像是 **切** 或 **削** 的基本动作
- morphologyEx() 像是 **一套完整的雕刻技法**（其中包含了切、削等基本动作）

```py
cv2.getStructuringElement(shape, ksize, anchor=(-1, -1))
```

ksize 通常为（3，3）/（5，5）/（7，7）。结构元素形状（shape）主要有 3 种：

1. ==MORPH_RECT：矩形（默认）==。适合方向不敏感的块状、方形物体。比如**车牌识别**时候的字符和背景、**文档处理**时的文字笔画、矩形核能均匀的腐蚀/膨胀。在不确定形状时也用它，相对处理的均匀。

2. ==MORPH_ELLIPSE：椭圆形==。适合圆形、弧形、无尖锐棱角的物体。血液涂片或者生物样本中的**细胞**、工业检测中的**气泡/液滴**、人的**虹膜**识别、去除白色的圆形小噪声。

3. ==MORPH_CROSS：十字形==。适合线状、十字交叉状、需要保持对角线特征的物体。**电路板检测**（PCB 板上的导线是线状的）、**指纹处理**（指纹的脊线是曲线，十字核能更好地保持连通性）、**字符细化**（在 OCR 预处理中，十字核可以用于骨架提取而不破坏笔画连接）。

```py
cv2.morphologyEx(src, op, kernel, dst=None, anchor=(-1, -1), iterations=1, borderType=cv2.BORDER_CONSTANT, borderValue=0)
```

**morphologyEx()** 高级函数中的参数，几乎和 腐蚀/膨胀 一样。多出来的新参数 op 表示形态学的操作类型，比如：

- 腐蚀为 ==cv2.MORPH_ERODE==，与 erode() 相同
- 膨胀为 ==cv2.MORPH_DILATE==，与 dilate() 相同
- 形态学梯度为 ==cv2.MORPH_GRADIENT==，膨胀图 - 腐蚀图，约等于边缘检测

这是我们已经接触过的三个操作。剩余的比如，开运算、闭运算、顶帽、黑帽、击中击不中（需二值图），且看后续。

### 2.3 开/闭运算

==开运算（Opening）== 先执行腐蚀操作，然后使用相同的核进行膨胀。通过这种方式，可以利用腐蚀的特点，消除一些不需要的像素。通过第二步的膨胀，减少腐蚀对主体的影响。op 的名称是 ==cv2.MORPH_OPEN==。

做一个简单的比方，在显微镜下，红细胞应该是独立的圆形细胞，但由于细胞密度大，很多细胞边缘刚好接触在一起，开运算可以断开这些细微的连接点，让计数更准确。

![2.3 开运算 - 先腐蚀后膨胀](/cv/ImageProcessing/05_xxx/07_opening.png)

总结一下，开运算可以用在：**去除 灰度或二值图 中的小噪点**、**分离“细小连接桥”，并保留主体形状**。但是，如果是重叠度比较高的那种连接，它是去除不了的哦。

==闭运算（closing）== 先执行膨胀操作，然后用同样的结构元素进行腐蚀。主要用于**填充物体内部的细小空洞**、**连接邻近的物体**、以及**平滑物体的边界**。op 的名称是 ==cv2.MORPH_CLOSE==。

还是打个比方，在车牌识别中，由于光照或污渍，一个完整的数字或字符可能断裂成了几个部分。闭运算可以将这些距离很近的断点连接起来，使其成为一个完整的连通区域。

![2.4 闭运算 - 先膨胀后腐蚀](/cv/ImageProcessing/05_xxx/07_closing.png)

可以看到，矩形刷子明显对字母 A 的结构造成了比较大的破坏，椭圆刷子就好了很多。虽然这是因为刷子的面积过大造成的，但是如果真的有这么大的断裂呢？遇到不同的情况需要不同的应对。

:::: code-group
::: code-group-item 闭运算代码

```py
import cv2
import numpy as np
import matplotlib.pyplot as plt

def show_img_by_plt(img, title, pos):
    ax = plt.subplot(1, 3, pos)
    plt.imshow(img, cmap="gray")
    plt.title(title)
    plt.axis('off')

# 创建一个带有空洞的字母‘A’的图像
image = np.zeros((200, 200), dtype=np.uint8)
cv2.putText(image, 'A', (70, 130), cv2.FONT_HERSHEY_SIMPLEX, 5, 255, 10)
cv2.circle(image, (98, 70), 6, 0, -1)  # 故意在字母中间挖一个洞
kernel1 = cv2.getStructuringElement(cv2.MORPH_RECT, (13, 13))  # 定义矩形核
kernel2 = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (13, 13))  # 定义椭圆核
closing1 = cv2.morphologyEx(image, cv2.MORPH_CLOSE, kernel1)
closing2 = cv2.morphologyEx(image, cv2.MORPH_CLOSE, kernel2)

plt.figure(figsize=(14, 8))
show_img_by_plt(image, "The letter A with a hole", 1)
show_img_by_plt(closing1, "Closing OP by Rectangular", 2)
show_img_by_plt(closing2, "Closing OP by Ellipse", 3)
plt.show()
```

:::
::: code-group-item 开运算代码

```py
import cv2
import numpy as np
import matplotlib.pyplot as plt

def show_img_by_plt(img, title, pos):
    ax = plt.subplot(1, 3, pos)
    plt.imshow(img, cmap="gray")
    plt.title(title)
    plt.axis('off')

# 生成一张有两个红细胞（圆形）+ 一条狭窄连接桥的二值图
img = np.zeros((300, 300), dtype=np.uint8)
cv2.circle(img, (90, 100), 50, 255, -1)
cv2.circle(img, (210, 100), 50, 255, -1)
cv2.rectangle(img, (135, 95), (165, 105), 255, -1)  # 模拟“细胞粘连桥”

kernel1 = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
kernel2 = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (15, 15))
opening1 = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel1)
opening2 = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel2)

# plt.figure(figsize=(14, 8), facecolor='lightblue')
plt.figure(figsize=(14, 8))
show_img_by_plt(img, "Small Connecting Bridge", 1)
show_img_by_plt(opening1, "Opening OP by Ellipse 5x5", 2)
show_img_by_plt(opening2, "Opening OP by Ellipse 15x15", 3)
plt.show()
```

:::
::::

### 2.4 顶帽与低帽（黑帽）

==顶帽（Top-hat）== 是用 **原图 - 开运算图**，提取 “比周围亮、尺寸比结构元小” 的区域，主要用于 **去除非均匀背景、提取亮小物体**。op 的名称为 ==cv2.MORPH_TOPHAT==。

==黑帽（Black-hat）== 是用 **闭运算图 - 原图**，提取 “比周围暗、尺寸比结构元小” 的区域，主要用于 **突出暗斑、修正不均匀光照**。op 的名称为 ==cv2.MORPH_BLACKHAT==。

我们想一下，开运算，是把小的亮点去掉了，那么原图减去开运算图，它们的差其实就是被去掉的地方。黑帽也是同理，闭运算图是补全了小的暗洞，那么与原图的差就是小暗洞那一部分。

![2.5 顶帽运算：原图 - 开运算图](/cv/ImageProcessing/05_xxx/08_tophat.png)

![2.6 黑帽运算：闭运算图 - 原图](/cv/ImageProcessing/05_xxx/08_blackhat.png)

:::: code-group
::: code-group-item 顶帽运算代码

```py
import cv2
import numpy as np
import matplotlib.pyplot as plt

def show_img_by_plt(img, title, pos):
    ax = plt.subplot(1, 3, pos)
    plt.imshow(img, cmap="gray")
    plt.title(title)
    plt.axis('off')

# 生成一张有两个红细胞（圆形）+ 一条狭窄连接桥的二值图
img = np.zeros((300, 300), dtype=np.uint8)
cv2.circle(img, (90, 100), 50, 255, -1)
cv2.circle(img, (210, 100), 50, 255, -1)
cv2.rectangle(img, (135, 95), (165, 105), 255, -1)  # 模拟“细胞粘连桥”

kernel2 = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (15, 15))
opening2 = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel2)
tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel2)

# plt.figure(figsize=(14, 8), facecolor='lightblue')
plt.figure(figsize=(14, 8))
show_img_by_plt(img, "Small Connecting Bridge", 1)
show_img_by_plt(opening2, "Opening OP by Ellipse 15x15", 2)
show_img_by_plt(tophat, "Top-hat OP by Ellipse 15x15", 3)
plt.show()
```

:::
::: code-group-item 黑帽运算代码

```py
import cv2
import numpy as np
import matplotlib.pyplot as plt

def show_img_by_plt(img, title, pos):
    ax = plt.subplot(1, 3, pos)
    plt.imshow(img, cmap="gray")
    plt.title(title)
    plt.axis('off')

# 创建一个带有空洞的字母‘A’的图像
image = np.zeros((200, 200), dtype=np.uint8)
cv2.putText(image, 'A', (70, 130), cv2.FONT_HERSHEY_SIMPLEX, 5, 255, 10)
cv2.circle(image, (98, 70), 6, 0, -1)  # 故意在字母中间挖一个洞

kernel2 = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (13, 13))  # 定义椭圆核
closing2 = cv2.morphologyEx(image, cv2.MORPH_CLOSE, kernel2)
blackhat = cv2.morphologyEx(image, cv2.MORPH_BLACKHAT, kernel2)

plt.figure(figsize=(14, 8))
show_img_by_plt(image, "The letter A with a hole", 1)
show_img_by_plt(closing2, "Closing OP by Ellipse 13x13", 2)
show_img_by_plt(blackhat, "Black-hat OP by Ellipse 13x13", 3)
plt.show()
```

:::
::::

### 2.5 击中-击不中变换

==击中-击不中变换（Hit-or-Miss Transform）== 在经典的数学形态学中是一个核心但不常用（在深度学习出现以前比较重要）的操作，主要用于检测特定形状模式。在二值图像 A 中，给定一个结构元 B，击中-击不中变换定义为：

$$
A\circledast{B}=(A\circleddash{B_{1}})(A^{c}\circleddash{B_{2}})
$$

其中，$B=(B_{1},B_{2})$，$B_{1}$ 要求必须命中（hit）的前景位置，$B_{2}$ 要求必须不命中（miss）的背景位置。$A^{c}$ 表示图像的补集（0 与 1 的翻转）。$\circleddash$ 表示形态学腐蚀。最终输出是一个二值图，仅在 “完全匹配指定形状” 处为 1。

可以理解为早期的**匹配模板**，只有当 “图像局部形状” 完全符合结构元定义的 “前景+背景” 模式时，才算“击中”。做一个小实验，在 10x10 的黑色像素图像中，给两个白色的点，再给一个白色的线段，我们将结构元定义为像素点检测的形式，测试一下：

```py
import cv2
import numpy as np
import matplotlib.pyplot as plt

def show_img_by_plt(img, title, pos):
    ax = plt.subplot(1, 3, pos)
    plt.imshow(img, cmap="gray")
    plt.title(title)
    plt.axis('off')

# 创建测试图：孤立点 + 连续线
img = np.zeros((10, 10), np.uint8)
img[2, 2] = 1
img[5, 3:7] = 1
img[8, 8] = 1

# 定义结构元：中心必须是 1，四周必须是 -1。执行击中-击不中变换
kernel = np.array([[ -1, -1, -1],
                   [ -1,  1, -1],
                   [ -1, -1, -1]], dtype=np.int8)
hitmiss = cv2.morphologyEx(img, cv2.MORPH_HITMISS, kernel)

plt.figure(figsize=(14, 8))
show_img_by_plt(img, "Image with Point and Line 10x10", 1)
show_img_by_plt(kernel, "Hit-or-Miss Point Kernel 3x3", 2)
show_img_by_plt(hitmiss, "Hit-or-Miss Result 10x10", 3)
plt.show()
```

![2.7 击中-击不中变换](/cv/ImageProcessing/05_xxx/09_hitormiss.png)

可以看到，已经成功匹配到了两个孤立的白色像素，去掉了线段。这里有一个小坑需要注意，这个方法的图像，要求是 **严格的二值图像**，前景为 1 或者 255，背景为 0。

但是在结构元 kernel 中，取值却有三种语义。1 表示 hit，-1 表示 miss，而 0 表示不关心、无关的内容。所以，如果我们把 kernel 周围的值从 -1 变成 0，实际执行的只是 “前景命中检测”，没有背景约束。这样的话线段也会被匹配到，可以尝试一下：

```py
kernel = np.array([[ 0, 0, 0],
                   [ 0, 1, 0],
                   [ 0, 0, 0]], dtype=np.int8)
```
