---
title: 05-形态学与运算
date: 2025/10/12
categories:
  - OpenCV
tags:
  - 图像处理
  - 形态学与运算
---

## 1. 运算类操作

### 1.1 饱和运算

饱和运算的原理十分简单，比如我们正常 RGB 的像素范围在 [0, 255] 之间，但是有的时候，做了加法、减法等等，导致其越界了。怎么办呢？**OpenCV 的处理方式**：会直接将值截断在边界值，小于 0 的被置为 0，大于 255 的被置为 255。

所以 ==饱和运算（Saturated Operation）== 在实现上就是通过最大值与最小值将运算限制在固定范围之内。我们先用 Python 的方法来做一个演示，通过 min 和 max 函数来截断：

```py
def opencv_add1(a, b):
    temp = a + b
    return min(max(temp, 0), 255)

opencv1 = opencv_add1(250, 50)
print("opencv add 1: ", opencv1)  # 255
```

但需要注意的是，OpenCV 的底层是 Numpy 数组，所以如果真实的要去做操作，需要使用 ==np.clip()== 函数进行截断，或者直接使用 where 条件判断也可以：

```py
def opencv_add2(a, b):
    # 1. 先将输入转换为更大的整数类型（比如 int32），防止中间计算溢出
    img1_int32 = a.astype(np.int32)
    img2_int32 = b.astype(np.int32)

    # 2. 使用 clip 函数手动饱和处理，裁剪到 [0, 255] 范围
    result_int32 = img1_int32 + img2_int32
    result_clipped = np.clip(result_int32, 0, 255)

    # 3. 最后再转换回 uint8 返回
    return result_clipped.astype(np.uint8)

opencv2 = numpy_add(np.uint8([[250]]),  np.uint8([[50]]))
print("opencv add 2: ", opencv2)

```

此外，np.uint8 在内存中占用 1 个字节（8 位），只能表示 0 到 255 这 256 个整数，在溢出后它的默认规撞上了 C 语言层面的整数溢出规则，也就是进行回绕的**模运算**：把 0 和 255 收尾相连，形成一个圆形环路。

```py
import numpy as np
import cv2

x = np.uint8([[250]])
y = np.uint8([[50]])

opencv = cv2.add(x, y)  # 250 + 50 = 300 -> 255
numpy = x + y  # 250 + 50 = 300 -> 44 (mod 256)

print("opencv:\n", opencv)  # 饱和运算
print("numpy:\n", numpy)  # 模运算
```

在我的例子中就是 mod 256。这种 Numpy 的模运算，和 OpenCV 的饱和运算是两码事儿，不要混淆了。

### 1.2 图像加减法

图像的加减法分别使用 ==cv2.add()==、==cv2.subtract()== 两个函数执行，如果读取的内容是图像，它们在内部会自动执行饱和运算。当然，从实现上来说，这两个函数不仅可以用于数组的逐元素运算，也可以对标量运算。

```py
import cv2
import numpy as np
import matplotlib.pyplot as plt

def show_img_by_plt(img, title, pos):
    ax = plt.subplot(1, 3, pos)
    plt.imshow(img)
    plt.title(title)
    plt.axis('off')

img = cv2.imread('01_luna.png', 1)  # 读取图像
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
M = np.ones(img.shape, dtype="uint8") * 255

result1 = cv2.add(img, M)
result2 = cv2.subtract(img, M)

plt.figure(figsize=(14, 8))
show_img_by_plt(img, "Original Image", 1)
show_img_by_plt(result1, "Add 255", 2)
show_img_by_plt(result2, "Subtract 255", 3)
plt.show()
```

![1.1 图像加减法越界结果](/cv/ImageProcessing/05_xxx/01_addsub1.png)

![1.2 图像加减法正常结果](/cv/ImageProcessing/05_xxx/02_addsub2.png)

### 1.3 图像混合

图像混合也是图像相加的一种，只不过可以赋予不同图像不同的权重进行相加。没错，就是我们的老朋友 ==cv2.addWeighted()== 函数，在《锐化与均衡化》中已经见过面了：

```py
dst = cv2.addWeighted(src1, alpha, src2, beta, gamma)
```

$$
dst(x,y)=src1(x,y)\cdot{\alpha}+src2(x,y)\cdot{\beta}+\gamma
$$

那我们就再来一个老熟人 ==Sobel 算子==，看一下 X 方向、Y 方向、XY 混合方向，边缘检测的结果分别是什么：

```py
import cv2
import matplotlib.pyplot as plt

def show_img_by_plt(img, title, pos):
    ax = plt.subplot(1, 3, pos)
    plt.imshow(img, cmap="gray")
    plt.title(title)
    plt.axis('off')

img = cv2.imread('01_luna.png', 0)  # 读取图像
gradient_x = cv2.Sobel(img, cv2.CV_32F, 1, 0, 3)
gradient_y = cv2.Sobel(img, cv2.CV_32F, 0, 1, 3)
gradient_xy = cv2.magnitude(gradient_x, gradient_y)

plt.figure(figsize=(14, 8))
show_img_by_plt(gradient_x, "Gradient X Float32", 1)
show_img_by_plt(gradient_y, "Gradient Y Float32", 2)
show_img_by_plt(gradient_xy, "Gradient XY Float32", 3)
plt.show()

plt.figure(figsize=(14, 8))
show_img_by_plt(cv2.convertScaleAbs(gradient_x), "Gradient X uint8", 1)
show_img_by_plt(cv2.convertScaleAbs(gradient_y), "Gradient Y uint8", 2)
show_img_by_plt(cv2.convertScaleAbs(gradient_xy), "Gradient XY uint8", 3)
plt.show()
```

![1.3 Sobel 算子 - 不同方向的梯度显示 浮点数](/cv/ImageProcessing/05_xxx/03_max1.png)

![1.4 Sobel 算子 - 不同方向的梯度显示 正整数](/cv/ImageProcessing/05_xxx/04_max2.png)

### 1.4 按位运算

## 2. 形态学操作

形态学运算是一种基于形状的图像处理技术，它是通过结构元素与图像进行特定运算的方式来改变图像的形态和特征。结构元素是一种小型、预定义的形状，通常是矩形、圆形或者椭圆形，可以与图像中的像素进行匹配。

形态学运算包括膨胀、腐蚀、开运算、闭运算等。其中膨胀操作可以将图像中的物体变大，使它更加连通；腐蚀操作则可以将图像中的物体变小，使它更加细化；开运算可以去除噪声，平滑图像的边缘；闭运算可以填补图像中物体的孔洞。

形态学在图像处理中应用广泛，特别是在图像分割、边缘检测、文本识别、计算机视觉等领域中。

### 2.1 膨胀与腐蚀

### 2.2 开/闭运算

### 2.3 梯度运算

### 2.4 顶帽与低帽（黑帽）

### 2.5 结构元素
