---
title: LA17.计算矩阵的特征值
date: 2025/10/02
categories:
  - 每日一题
tags:
  - AI题库
  - 线性代数
---

#### 难度：简单

实现一个函数，计算 2×2 矩阵的特征值。

- **输入描述**：第一行输入一个 2×2 的二维数组（矩阵），数组中的元素可以是整数或浮点数。
- **输出描述**：输出一个包含两个特征值的列表，特征值可以是实数或复数。按从大到小的顺序返回特征值。

:::: code-group
::: code-group-item 代码框架

```py
from typing import List, Union

def calculate_eigenvalues(matrix: List[List[Union[int, float]]]) -> List[float]:
    pass

def main():
    matrix = eval(input())
    result = calculate_eigenvalues(matrix)
    print(result)

if __name__ == "__main__":
    main()
```

:::

::: code-group-item 示例 1

```py
# 输入：
[[1, 2], [2, 1]]

# 输出：
[3.0, -1.0]
```

:::
::::

---

#### 特征值与特征向量

给定一个方阵 $A\in{R^{n*n}}$，如果存在标量 $\lambda$ 和非零向量 $\vec{v}$，使得 $A\vec{v}=\lambda{\vec{v}}$，那么：

- $\lambda$ 称为矩阵 A 的 特征值（Eigenvalue）
- $\vec{v}$ 称为对应的 特征向量（Eigenvector）

直观解释：特征向量被矩阵 A 作用后，方向不变，只是被拉伸或压缩了 $\lambda$ 倍。**特征值的计算** 是要求解 ==$det(A-\lambda{I})=0$==，这个方程是一个关于 $\lambda$ 的多项式方程，称为 **特征方程（Characteristic polynomial）**，方程的根就是特征值。

对于 2 x 2 的矩阵而言，以示例 1 为例子，矩阵形式为：

$$
A
=\begin{bmatrix} a & b \\ c & d \end{bmatrix}
=\begin{bmatrix} 1 & 2 \\ 2 & 1 \end{bmatrix}
$$

特征方程为：

$$
det\begin{bmatrix} a-\lambda & b \\ c & d-\lambda \end{bmatrix}
=det\begin{bmatrix} 1-\lambda & 2 \\ 2 & 1-\lambda \end{bmatrix}
$$

展开之后换算，得到二次方程：

$$
(a-\lambda)(d-\lambda)-bc = \lambda^{2}-(a+d)\lambda+(ad-bc)=0
$$

- $a+d=tr(A)$，表示矩阵的迹，矩阵的主对角线之和；
- $ad-bc=det(A)$，表示矩阵 A 的行列式。

所以最终的公式形式可以写为：

$$
\lambda^{2} - tr(A)\lambda + det(A) = 0
$$

带入到示例 1 的矩阵中，就是解一元二次方程：$\lambda^{2}-2\lambda-3=0$，它的解为 $\lambda_{1}=3, \lambda_{2}=-1$。

#### 解题思路 1：Numpy

它这个难度突然骤减到这样，我还挺不适应的。这个题甚至比 LA1 还简单，就是两个向量相乘，直接用 @ 或 np.dot() 完成即可。

```py
import numpy as np

def calculate_dot_product(vec1, vec2):
    return vec1 @ vec2
```

#### 解题思路 2：Python

```py
def calculate_dot_product(vec1, vec2):
    result = sum([vec1[i] * vec2[i] for i in range(len(vec1))])
    return result

if __name__ == "__main__":
    vec1 = eval(input())
    vec2 = eval(input())
    print(calculate_dot_product(vec1, vec2))
```
