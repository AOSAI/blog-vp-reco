---
title: LA17.计算矩阵的特征值
date: 2025/10/02
categories:
  - 每日一题
tags:
  - AI题库
  - 线性代数
---

#### 难度：中等

实现一个函数，计算 2×2 矩阵的特征值。

- **输入描述**：第一行输入一个 2×2 的二维数组（矩阵），数组中的元素可以是整数或浮点数。
- **输出描述**：输出一个包含两个特征值的列表，特征值可以是实数或复数。按从大到小的顺序返回特征值。

:::: code-group
::: code-group-item 代码框架

```py
from typing import List, Union

def calculate_eigenvalues(matrix: List[List[Union[int, float]]]) -> List[float]:
    pass

def main():
    matrix = eval(input())
    result = calculate_eigenvalues(matrix)
    print(result)

if __name__ == "__main__":
    main()
```

:::

::: code-group-item 示例 1

```py
# 输入：
[[1, 2], [2, 1]]

# 输出：
[3.0, -1.0]
```

:::
::::

---

#### 特征值与特征向量

给定一个方阵 $A\in{R^{n*n}}$，如果存在标量 $\lambda$ 和非零向量 $\vec{v}$，使得 $A\vec{v}=\lambda{\vec{v}}$，那么：

- $\lambda$ 称为矩阵 A 的 特征值（Eigenvalue）
- $\vec{v}$ 称为对应的 特征向量（Eigenvector）

直观解释：特征向量被矩阵 A 作用后，方向不变，只是被拉伸或压缩了 $\lambda$ 倍。**特征值的计算** 是要求解 ==$det(A-\lambda{I})=0$==，这个方程是一个关于 $\lambda$ 的多项式方程，称为 **特征方程（Characteristic polynomial）**，方程的根就是特征值。

对于 2 x 2 的矩阵而言，以示例 1 为例子，矩阵形式为：

$$
A
=\begin{bmatrix} a & b \\ c & d \end{bmatrix}
=\begin{bmatrix} 1 & 2 \\ 2 & 1 \end{bmatrix}
$$

特征方程为：

$$
det\begin{bmatrix} a-\lambda & b \\ c & d-\lambda \end{bmatrix}
=det\begin{bmatrix} 1-\lambda & 2 \\ 2 & 1-\lambda \end{bmatrix}
$$

展开之后换算，得到二次方程：

$$
(a-\lambda)(d-\lambda)-bc = \lambda^{2}-(a+d)\lambda+(ad-bc)=0
$$

- $a+d=tr(A)$，表示矩阵的迹，矩阵的主对角线之和；
- $ad-bc=det(A)$，表示矩阵 A 的行列式。

所以最终的公式形式可以写为：

$$
\lambda^{2} - tr(A)\lambda + det(A) = 0
$$

带入到示例 1 的矩阵中，就是解一元二次方程：$\lambda^{2}-2\lambda-3=0$，直接套公式：

$$
\lambda_{1,2}=\frac{tr(A)\pm\sqrt{tr(A)^{2}-4det(A)}}{2}
$$

得出它的解为 $\lambda_{1}=3, \lambda_{2}=-1$。

#### 解题思路 1：Numpy

Numpy 中有两个函数可以解决这个问题，**np.linalg.eigvals** 与 **np.linalg.eig**：

1. ==np.linalg.eigvals==：只返回特征值 value。
2. ==np.linalg.eig==：即返回特征值 value（一维数组），也返回特征向量 vector （二维数组，每一列为特征向量）。

但是很奇怪，本来测试用例应该直接得出 3.0 这样一个结果的，结果得出来 3.0000000000000004，可能是 np 内部的矩阵运算过于精细，导致二进制系统出现了误差。所以我用 round 函数进行了小数点后的截取。

其次，它要求特征值从大到小排序，所以 np 中的 sort()函数只能从小到大排序，所以我们使用切片的方式对其进行逆序。

```py
import numpy as np

def calculate_eigenvalues(matrix: List[List[Union[int, float]]]) -> List[float]:
    arr = np.array(matrix)
    result = np.round(np.linalg.eigvals(arr), 1)
    return np.sort(result)[::-1].tolist()
```

#### 解题思路 2：Python

手搓的思路在前面讲过了，计算直接套公式：

$$
\lambda_{1,2}=\frac{tr(A)\pm\sqrt{tr(A)^{2}-4det(A)}}{2}
$$

```py
from typing import List, Union

def calculate_eigenvalues(matrix: List[List[Union[int, float]]]) -> List[float]:
    a, b = matrix[0]
    c, d = matrix[1]

    trace = a + d
    det = a*d - b*c
    disc = (trace**2 - 4*det) ** 0.5
    lambda1 = (trace + disc) / 2
    lambda2 = (trace - disc) / 2

    return [lambda1, lambda2] if lambda1 > lambda2 else [lambda2, lambda1]
```
