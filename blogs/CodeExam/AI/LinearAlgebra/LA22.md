---
title: LA22.计算相关矩阵
date: 2025/10/17
categories:
  - 每日一题
tags:
  - AI题库
  - 线性代数
---

#### 难度：中等

实现一个函数来计算数据集的相关矩阵。相关矩阵反映了变量之间的线性相关程度，其中每个元素表示对应变量之间的皮尔逊相关系数。

- **输入描述**：函数`calculate_correlation_matrix`接收两个参数：
  1. X：第一个数据矩阵，numpy 二维数组，形状为(n_samples, n_features_1)
  2. Y：第二个数据矩阵（可选），numpy 二维数组，形状为(n_samples, n_features_2)
  3. 如果 Y 为 None，则计算 X 与自身的相关矩阵
- **输出描述**：返回一个 numpy 二维数组，表示相关矩阵：
  1. 如果只有 X 输入，返回形状为(n_features_1, n_features_1)的矩阵
  2. 如果有 Y 输入，返回形状为(n_features_1, n_features_2)的矩阵
  3. 对角线元素（自相关）应该为 1.0

:::: code-group
::: code-group-item 代码框架

```py
import numpy as np

def calculate_correlation_matrix(X, Y=None):
	# Your code here
	pass

if __name__ == "__main__":
    X = np.array(eval(input()))
    print(calculate_correlation_matrix(X))
```

:::

::: code-group-item 示例 1

```py
# 输入：
[[1, 2], [3, 4], [5, 6]]

# 输出：
[[1. 1.]
 [1. 1.]]
```

:::
::::

---

#### 皮尔逊相关系数

==皮尔逊相关系数（Pearson Correlation Coefficient）== 是用于度量两个变量之间线性关系强度和方向的统计量。其值域在 [-1, 1] 之间：

- 当皮尔逊相关系数为 1 / 0 / -1 时，表示两个变量 完全正相关 / 没有线性关系 / 完全负相关。
- 当皮尔逊系数的绝对值 >0.8 时极强相关、>0.6 时强相关、>0.4 时中度相关、>0.2 时弱相关。

它的计算公式如下（$X_{i}/Y_{i}$ 表示第 i 个样本；$\bar{X}/\bar{Y}$ 表示样本均值；n 是样本的数量）：

$$
R = \frac{
\sum^{n}_{i=1}(X_{i}-\bar{X})(Y_{i}-\bar{Y})
}{\sqrt{\sum^{n}_{i=1}(X_{i}-\bar{X})^{2}}\sqrt{\sum^{n}_{i=1}(Y_{i}-\bar{Y})^{2}}}
$$

分子部分是两个变量之间协方差的计算公式，它衡量了两个变量共同变化的趋势。分母部分是两个变量各自标准差的乘积，用于对协方差进行标准化处理，使得相关系数的取值范围在 -1 到 1 之间。

#### 解题思路 1：Numpy 操作

首先是按照公式的逻辑直接计算：

```py
import numpy as np

def calculate_correlation_matrix(X, Y=None):
    X = np.array(X, dtype=float)
    Y = X if Y is None else np.array(Y, dtype=float)

    # 减均值，计算协方差矩阵
    X_centered = X - X.mean(axis=0)
    Y_centered = Y - Y.mean(axis=0)
    cov = X_centered.T @ Y_centered / (X.shape[0] - 1)

    # 标准差向量
    std_X = np.std(X, axis=0, ddof=1)
    std_Y = np.std(Y, axis=0, ddof=1)

    # 相关系数矩阵
    corr = cov / np.outer(std_X, std_Y)
    return corr
```

也可以直接使用 ==np.corrcoef(x, y)== 函数进行计算，但这个函数用起来，需要注意的地方有很多：

```py
np.corrcoef(x, y=None, rowvar=True)
```

| 场景                     | 数据格式                | 正确用法                        |
| ------------------------ | ----------------------- | ------------------------------- |
| 两个一维向量             | [N]                     | np.corrcoef(x, y)[0,1]          |
| 一个二维矩阵（行是变量） | [num_vars, num_samples] | np.corrcoef(X)                  |
| 一个二维矩阵（列是变量） | [num_samples, num_vars] | np.corrcoef(X, rowvar=False)    |
| 两个矩阵 X, Y            | 同样本数                | np.corrcoef(X, Y, rowvar=False) |

但是但是，当你传入两个矩阵 X 和 Y 时，它会把它们拼接起来再计算整体的相关系数矩阵。相当于这样：

```py
np.corrcoef(X, Y, rowvar=False) =
np.corrcoef(np.concatenate((X, Y), axis=1), rowvar=False) =
┌──────────────┬──────────────┐
│  C_XX (X,X)  │  C_XY (X,Y)  │
├──────────────┼──────────────┤
│  C_YX (Y,X)  │  C_YY (Y,Y)  │
└──────────────┴──────────────┘
```

但是根据题目要求，我们要的只是 C_XY 的部分，所以我们要把它取出来：

```py
import numpy as np

def calculate_correlation_matrix(X, Y=None):
    X = np.array(X, dtype=float)
    Y = X if Y is None else np.array(Y, dtype=float)

    C = np.corrcoef(X, Y, rowvar=False)
    n = X.shape[1]
    C_xy = C[:n, n:]
    return C_xy
```

#### 解题思路 2：Python 手搓

手搓的思路和 Numpy 的第一种计算方法是一样的，先把皮尔逊相关系数的公式计算解决了。首先我们定义三个函数，==mean、covariance、std==，分别用于计算 **均值、协方差、标准差**。

```py
# 计算特征的均值
def mean(feature):
    return sum(feature) / len(feature)

# 计算两特征之间的协方差
def covariance(x, y):
    mx, my = mean(x), mean(y)
    return sum((xi - mx) * (yi - my) for xi, yi in zip(x, y)) / (len(x) - 1)

# 计算标准差
def std(x):
    mx = mean(x)
    return (sum((xi - mx) ** 2 for xi in x) / (len(x) - 1)) ** 0.5
```

接下来就是借助这三个公式，来构造相关矩阵。要记得，题目给的矩阵形状是 (samples, features)，我们要返回的矩阵形状是 (features, features)。前行，后列，所以我们要提取两个矩阵的列元素，来进行计算。

```py
# 提取列向量
def get_col(matrix, j):
    return [row[j] for row in matrix]

def calculate_correlation_matrix(X, Y=None):
    Y = X if Y is None else Y
    n_features_X = len(X[0])
    n_features_Y = len(Y[0])

    # 构造相关矩阵
    corr = [[0.0 for _ in range(n_features_Y)] for _ in range(n_features_X)]

    for i in range(n_features_X):
        col_x = get_col(X, i)
        for j in range(n_features_Y):
            col_y = get_col(Y, j)
            denom = std(col_x) * std(col_y)
            corr[i][j] = 0.0 if denom == 0 else covariance(col_x, col_y) / denom

    return corr
    # return format_matrix_like_numpy(corr)

if __name__ == "__main__":
    X = eval(input())
    print(calculate_correlation_matrix(X))
```

到这里正儿八紧的运算就结束，但是如果你去提交，肯定是不对的，因为它的输出默认是 Numpy 运算后的输出，所以必须将其转换为 Numpy 风格。三个步骤：

1. 首先，将 “1.0” 转化为 “1.”，将其他的输出，转化为 “八位小数”。
2. 其次，计算每列的最大宽度，根据这个值进行左对齐操作。
3. 最后，定义输出的格式，逗号变空格，第一行开始是 “[[”，最后一行结尾是 “]]”。

```py
# 矩阵的 Numpy 风格输出
def format_matrix_like_numpy(matrix, precision=8):
    formatted = []
    for row in matrix:
        prow = []
        for v in row:
            # 判断是否为1.0或-1.0（避免浮点误差），否则保留指定小数位
            if abs(v - 1.0) < 1e-12:
                s = "1."
            elif abs(v + 1.0) < 1e-12:
                s = "-1."
            else:
                s = f"{v:.{precision}f}".rstrip("0").rstrip(".")
            prow.append(s)
        formatted.append(prow)

    # 计算每列的最大宽度
    n_cols = len(formatted[0])
    col_widths = [0] * n_cols
    for j in range(n_cols):
        col_widths[j] = max(len(row[j]) for row in formatted)

    # 将每个元素，根据每列 col_widths，右补空格到 max_len
    lines = []
    for row in formatted:
        parts = [ row[j].ljust(col_widths[j]) for j in range(n_cols) ]
        line = "[{}]".format(" ".join(parts))
        lines.append(line)

    if not lines:
        return "[]"

    out_lines = []
    for i, line in enumerate(lines):
        if i == 0:
            out_lines.append("[[" + line[1:])  # 首行：[[ 开头
        elif i == len(lines) - 1:
            out_lines.append(" " + line[:-1] + "]]")  # 末行：]] 结尾
        else:
            out_lines.append(" " + line)  # 中间行正常缩进
    return "\n".join(out_lines)
```

==ljust== 是 Python 字符串的方法，用于左对齐一个字符串，并在右边填充空格（或指定字符）到指定宽度。与其对应，==rjust== 用于右对齐一个字符串。

```py
s.ljust(width, fillchar=' ')
```

**s** 表示原始字符串；**width** 表示 最终字符串的长度；**fillchar** 表示填充字符（默认是空格）。
