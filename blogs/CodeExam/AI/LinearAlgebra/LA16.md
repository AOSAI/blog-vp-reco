---
title: LA16.多项式特征的Phi变换
date: 2025/10/02
categories:
  - 每日一题
tags:
  - AI题库
  - 线性代数
---

#### 难度：简单

实现一个函数以执行 Phi 变换，通过生成多项式特征将输入特征映射到更高维的空间。这种变换允许像线性回归这样的模型通过引入表示原始输入特征多项式组合的新特征维度来拟合非线性数据。

例如，对于输入特征 $x，degree=2$ 的多项式特征将生成 $[1,x,x^{2}]$。这种转换使得线性模型可以学习非线性关系。

- **输入描述**：
  1. 第一行为一个数值列表，表示需要转换的特征值
  2. 第二行为一个整数，表示多项式的次数（degree）
- **输出描述**：输出一个嵌套列表，其中每个内部列表包含一个数据点的转换后的特征。
  1. 每个内部列表的长度为 degree+1，包含从 0 次幂到 degree 次幂的值。
  2. 如果 degree 小于 0 或输入列表为空，则返回空列表。

:::: code-group
::: code-group-item 代码框架

```py
import numpy as np

def phi_transform(data: list[float], degree: int) -> list[list[float]]:
	"""
	Perform a Phi Transformation to map input features into a higher-dimensional space by generating polynomial features.

	Args:
		data (list[float]): A list of numerical values to transform.
		degree (int): The degree of the polynomial expansion.

	Returns:
		list[list[float]]: A nested list where each inner list represents the transformed features of a data point.
	"""
	pass

if __name__ == "__main__":
    data = eval(input())
    degree = int(input())
    print(phi_transform(data, degree))
```

:::

::: code-group-item 示例 1

```py
# 输入：
[2.0, 3.0]
2

# 输出：
[[1.0, 2.0, 4.0], [1.0, 3.0, 9.0]]
```

:::
::::

---

#### 解题思路 1：Python

解题思路很简单，首先是对于输出条件 2 的判定，如果 degree 小于 0 或者 data 为空，返回空列表，直接放在顶端判断。

其次是新列表的构造，有几个值就有几个新的一维数组，所以最外层的循环是 len(data)。其内部之所以要用三个条件判断，是因为 if else 的资源消耗远远小于对数据做指数运算，只有需要对其平方、立方、以及更多的时候，才进行第二次循环，做指数运算。

```py
def phi_transform(data: list[float], degree: int) -> list[list[float]]:
	if degree < 0 or len(data) == 0:
		return []

	arr = []
	for i in range(len(data)):
		if degree == 0:
			arr.append([1.0])
			continue

		temp_data = float(data[i])
		temp = [1.0, temp_data]
		if degree == 1:
			arr.append(temp)
		else:
			for j in range(2, degree+1):
				temp.append(temp_data**j)
		arr.append(temp)

	return arr
```

#### 解题思路 2：Numpy

Numpy 中的 **多项式特征扩展** 是有对应的函数的。==vander(data)== 函数生成范德蒙矩阵：

1. **data 参数**：表示输入的数组数据，可以是 python 的 list，也可以是 np 的 array。
2. **N 参数**：表示内部列表的长度，如题目描述所说 = degree + 1。
3. **increasing 参数**：True 表示升序排列 [1, 3, 9]；False 表示降序排列 [9, 3, 1]。

```py
import numpy as np

def phi_transform(data: list[float], degree: int) -> list[list[float]]:
	if degree < 0 or len(data) == 0:
		return []

	new_data = [float(data[i]) for i in range(len(data))]
	return np.vander(new_data, N=degree+1, increasing=True).tolist()
```
