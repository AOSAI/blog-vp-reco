---
title: LA7.åŸºå‘é‡å˜æ¢çŸ©é˜µ
date: 2025/09/28
categories:
  - æ¯æ—¥ä¸€é¢˜
tags:
  - AIé¢˜åº“
  - çº¿æ€§ä»£æ•°
---

#### éš¾åº¦ï¼šç®€å•

åœ¨çº¿æ€§ä»£æ•°ä¸­ï¼ŒåŒä¸€ä¸ªå‘é‡å¯ä»¥åœ¨ä¸åŒçš„åŸºä¸‹è¡¨ç¤ºã€‚ç»™å®š $R^3$ ç©ºé—´ä¸­ä¸¤ç»„åŸºå‘é‡ B å’Œ Cï¼Œå®ç°ä¸€ä¸ªå‡½æ•°æ¥è®¡ç®—ä»åŸº C åˆ°åŸº B çš„å˜æ¢çŸ©é˜µ Pã€‚

- **è¾“å…¥æè¿°**ï¼šå‡½æ•°`transform_basis`æ¥æ”¶ä¸¤ä¸ªå‚æ•°ï¼š
  1. Bï¼š3Ã—3 çŸ©é˜µï¼Œè¡¨ç¤ºç¬¬ä¸€ç»„åŸºå‘é‡ï¼ˆæ¯åˆ—æ˜¯ä¸€ä¸ªåŸºå‘é‡ï¼‰
  2. Cï¼š3Ã—3 çŸ©é˜µï¼Œè¡¨ç¤ºç¬¬äºŒç»„åŸºå‘é‡ï¼ˆæ¯åˆ—æ˜¯ä¸€ä¸ªåŸºå‘é‡ï¼‰
- **è¾“å‡ºæè¿°**ï¼šè¿”å›ä¸€ä¸ª 3Ã—3 çš„çŸ©é˜µ Pã€‚

:::: code-group
::: code-group-item ä»£ç æ¡†æ¶

```py
import numpy as np

def transform_basis(B, C):
    pass

if __name__ == "__main__":
    B = np.array(eval(input()))
    C = np.array(eval(input()))
    print(transform_basis(B, C))
```

:::

::: code-group-item ç¤ºä¾‹ 1

```py
# è¾“å…¥ï¼š
[[1, 0, 0], [0, 1, 0], [0, 0, 1]]
[[1, 1, 0], [0, 1, 1], [1, 0, 1]]

# è¾“å‡ºï¼š
[[0.5, -0.5, 0.5], [0.5, 0.5, -0.5], [-0.5, 0.5, 0.5]]
```

:::
::::

---

#### çŸ©é˜µçš„é€†çŸ©é˜µï¼ˆinverseï¼‰

çŸ©é˜µçš„è½¬ç½®é€šå¸¸å†™ä¸º $A^{T}$ æˆ– $A^{'}$ï¼Œå®ƒåªæ˜¯æŠŠè¡Œå’Œåˆ—åšäº†ä¸€ä¸ªäº¤æ¢ã€‚è€Œ ==é€†çŸ©é˜µ== çš„å®šä¹‰æ˜¯ï¼Œè‡ªèº«ä¸é€†çŸ©é˜µç›¸ä¹˜å¿…ç„¶ç­‰äº**å•ä½çŸ©é˜µ I**ã€‚

$$
A^{-1}A = AA^{-1} = I
$$

åªæœ‰å½“çŸ©é˜µæ˜¯ ==æ­£äº¤çŸ©é˜µï¼ˆorthogonal matrixï¼‰== çš„æ—¶å€™ï¼Œè½¬ç½®æ˜¯ç­‰äºé€†çŸ©é˜µçš„ã€‚æ¯”å¦‚æ—‹è½¬çŸ©é˜µï¼š

$$
R=
\begin{bmatrix}
\cos{\theta} & -\sin{\theta} \\ \sin{\theta} & \cos{\theta}
\end{bmatrix}
\xrightarrow{\text{æ­£äº¤çŸ©é˜µçš„æ€§è´¨}}
R^{-1}=R^{T}
$$

==é€†çŸ©é˜µçš„è®¡ç®—å…¬å¼ï¼ˆ2Ã—2ã€3Ã—3ã€é€šç”¨å…¬å¼ï¼‰ï¼š==

1. **2Ã—2 çŸ©é˜µçš„é€†**ï¼š==è®¡ç®—è¡Œåˆ—å¼ï¼Œå¦‚æœä¸ç­‰äº 0 åˆ™æœ‰é€†ã€‚== ğŸ‘‰ è®°å¿†å°æŠ€å·§ï¼šå¯¹è§’çº¿å…ƒç´ äº¤æ¢ä½ç½®ï¼Œå‰¯å¯¹è§’çº¿å–è´Ÿå·ï¼Œæœ€åé™¤ä»¥è¡Œåˆ—å¼ã€‚

$$
\text{çŸ©é˜µï¼š}A= \begin{bmatrix} a & b \\ c & d \end{bmatrix} \\[0.5em]
\text{è¡Œåˆ—å¼ï¼š}det(A)=adâˆ’bc \not = 0 \\[0.5em]
\text{é€†çŸ©é˜µå…¬å¼ï¼š}A^{-1}=\frac{1}{ad-bc} \begin{bmatrix} d & -b \\ -c & a \end{bmatrix}
$$

2. **3x3 ä¸é€šç”¨å…¬å¼**ï¼šçŸ©é˜µ A çš„ä¼´éšçŸ©é˜µ adj é™¤ä»¥çŸ©é˜µ A çš„è¡Œåˆ—å¼ detã€‚

$$
\text{é€šç”¨å…¬å¼ï¼š}A^{-1}=\frac{1}{det(A)}\cdot{adj(A)} \\[0.5em]
$$

ä¼´éšçŸ©é˜µæ˜¯æŒ‡æ¯ä¸ªå…ƒç´ æ›¿æ¢æˆå¯¹åº”çš„ä»£æ•°ä½™å­å¼ï¼Œå†æ•´ä½“è½¬ç½®ã€‚ä¸è¿‡å®é™…è®¡ç®—æ—¶ä¸ä¼šçœŸç”¨è¿™ä¸ªå…¬å¼ï¼Œå› ä¸ºå¤æ‚åº¦é«˜ï¼Œæ•°å€¼ç¨³å®šæ€§å·®ã€‚ç°ä»£è®¡ç®—æœºé€šå¸¸ç”¨ **é«˜æ–¯æ¶ˆå…ƒæ³•** æˆ– **LU åˆ†è§£** æ¥ç®—é€†çŸ©é˜µã€‚

#### è§£é¢˜æ€è·¯ 1ï¼šNumpy æ•°ç»„å¤„ç†

$C\cdot{P}=B$ï¼Œè¯¥å…¬å¼å¯ä»¥å˜æ¢ä¸º $P=B\cdot{C^{-1}}$ã€‚åœ¨ Numpy ä¸­ä½¿ç”¨ ==np.linalg.inv== å‡½æ•°è®¡ç®—é€†çŸ©é˜µï¼Œæ ¸å¿ƒæ˜¯ **LU åˆ†è§£**ã€‚å®ƒè°ƒç”¨äº†ä¸€ä¸ªé«˜æ€§èƒ½çº¿æ€§ä»£æ•°åº“ **LAPACK**ï¼Œå¦‚æœæ˜¯åŒç²¾åº¦æµ®ç‚¹æ•°ï¼š

1. dgetrfï¼šåš LU åˆ†è§£ï¼ˆæŠŠçŸ©é˜µåˆ†è§£ä¸ºä¸‹ä¸‰è§’ L å’Œä¸Šä¸‰è§’ Uï¼Œå¸¦è¡Œäº¤æ¢ï¼‰ã€‚
2. dgetriï¼šåŸºäº LU åˆ†è§£ç»“æœï¼Œç®—å‡ºé€†çŸ©é˜µã€‚

```py
import numpy as np

def transform_basis(B, C):
    return (np.linalg.inv(C) @ B).tolist()
```

#### è§£é¢˜æ€è·¯ 2ï¼šPython æ•°ç»„æ‰‹æ“

é«˜æ–¯æ¶ˆå…ƒæ³•å’Œ LU åˆ†è§£æœ¬è´¨ä¸Šæ˜¯åŒä¸€å›äº‹ã€‚é«˜æ–¯æ¶ˆå…ƒä¸€æ­¥æ­¥æ¶ˆå…ƒï¼Œæœ€åå¾—åˆ°ä¸Šä¸‰è§’çŸ©é˜µï¼›LU åˆ†è§£å°±æ˜¯æŠŠæ•´ä¸ªæ¶ˆå…ƒè¿‡ç¨‹æŠ½è±¡ä¸º A=LUã€‚å·®åˆ«åœ¨äºå®ç°å½¢å¼ï¼šLU åˆ†è§£æ›´ç»“æ„åŒ–ã€å¯å¤ç”¨ï¼ˆæ¯”å¦‚è§£å¤šä¸ªæ–¹ç¨‹ç»„ï¼‰ã€‚==LU åˆ†è§£ = ç³»ç»ŸåŒ–çš„é«˜æ–¯æ¶ˆå…ƒ==ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œæ‰‹æ“ä¸€ä¸‹ LU åˆ†è§£çš„å†…å®¹ã€‚

é¦–å…ˆæ˜¯è¾“å…¥è¦æ”¹ä¸€ä¸‹ï¼Œä¹‹å‰è¯»å–ä¹‹åç›´æ¥è½¬æ¢ä¸º Numpy äº†ï¼Œè¿™é‡Œè½¬æ¢ä¸º listã€‚

```py
def transform_basis(B, C):
    # å…¨éƒ¨è½¬æ¢ä¸ºæµ®ç‚¹æ•°
    B = [[float(x) for x in row] for row in B]
    C = [[float(x) for x in row] for row in C]

    L, U = lu_decomposition(C)  # æ‰‹å†™LUåˆ†è§£
    C_inv = inverse_from_lu(L, U)  # æ±‚é€†çŸ©é˜µ --> è§£çº¿æ€§æ–¹ç¨‹ç»„
    return mat_mul(C_inv, B)  # è®¡ç®—çŸ©é˜µä¹˜æ³•


if __name__ == "__main__":
    import ast
    B = ast.literal_eval(input())  # å–è¾“å…¥1ï¼Œè½¬æ¢ä¸ºlist
    C = ast.literal_eval(input())  # å–è¾“å…¥2ï¼Œè½¬æ¢ä¸ºlist
    print(transform_basis(B, C))
```

æ¥ä¸‹æ¥çœ‹ lu_decomposition å‡½æ•°ï¼Œæ‰‹å†™ LU åˆ†è§£ã€‚Doolittle LU åˆ†è§£çš„æ ¸å¿ƒå¾ªç¯ï¼š

1. **å…ˆæŠŠ L çš„å¯¹è§’çº¿è®¾ç½®ä¸º 1ï¼ˆDoolittle æ–¹æ³•çš„çº¦å®šï¼‰**
2. **è®¡ç®—ä¸Šä¸‰è§’çŸ©é˜µ U**ï¼Œå…¬å¼åŸç†ï¼š

$$
U[i][j]=A[i][j]-\sum^{i-1}_{k=0}L[i][k]U[k][j]
$$

3. **è®¡ç®—ä¸‹ä¸‰è§’çŸ©é˜µ L**ï¼Œå…¬å¼åŸç†ï¼š

$$
L[j][i]=\frac{1}{U[i][i]}(A[j][i]-\sum^{i-1}_{k=0}L[j][k]U[k][i])
$$

```py
def lu_decomposition(A):
    n = len(A)
    L = [[0.0]*n for _ in range(n)]
    U = [[0.0]*n for _ in range(n)]

    for i in range(n):
        L[i][i] = 1.0  # å¯¹è§’çº¿ L[i][i] = 1

        # è®¡ç®— U çš„ç¬¬ i è¡Œ
        for j in range(i, n):
            s = sum(L[i][k]*U[k][j] for k in range(i))
            U[i][j] = A[i][j] - s

        # è®¡ç®— L çš„ç¬¬ i åˆ—
        for j in range(i+1, n):
            s = sum(L[j][k]*U[k][i] for k in range(i))
            L[j][i] = (A[j][i] - s) / U[i][i]

    return L, U
```

$$
L=
\begin{bmatrix}
1.0 & 0.0 & 0.0 \\ 0.0 & 1.0 & 0.0 \\ 1.0 & -1.0 & 1.0
\end{bmatrix}
U=
\begin{bmatrix}
1.0 & 1.0 & 0.0 \\ 0.0 & 1.0 & 1.0 \\ 0.0 & 0.0 & 2.0
\end{bmatrix}
$$

ç°åœ¨æ¥çœ‹ inverse_from_lu å‡½æ•°ï¼Œæ±‚è§£å¤šä¸ªæ–¹ç¨‹ç»„ã€‚å…ˆè®¡ç®—**å‰ä»£ï¼ˆforwardï¼‰**ï¼Œå†æŠŠå¾—åˆ°çš„ç»“æœé€å»**å›ä»£ï¼ˆbackwardï¼‰**ï¼Œå¾ªç¯è®¡ç®—ï¼Œå°±å¾—åˆ°äº†è½¬ç½®åçš„é€†çŸ©é˜µã€‚ä»¥ä¸€è½®å¾ªç¯åšä¸€ä¸ªæ¼”ç¤ºï¼š

1. ==ç¬¬ä¸€ä¸ª e ä¸ºï¼š$e_{0}=[1.0,0.0,0.0]^{T}$ã€‚è®¡ç®—å‰ä»£ $L_{y}=e_{0}$==ï¼š

   - $y[0]=e[0]-sum(Null)=1.0-0.0=1.0$ï¼Œ**range(0,0)ä¸ºç©º**
   - $y[1]=e[1]-sum(L[1,0]\cdot{y[0]})=0.0-0.0=0.0$
   - $y[2]=e[2]-sum(L[2,0]\cdot{y[0]}+L[2,1]\cdot{y[1]})=0.0-1.0=-1.0$

2. ==ç¬¬ä¸€ä¸ªå‰ä»£ç»“æœ y ä¸ºï¼š$y_{0}=[1.0,0.0,-1.0]^{T}$ã€‚è®¡ç®—åä»£ $U_{x}=y_{0}$==ï¼š

   - $x[2]=(y[2]-sum(Null))/U[2,2]=-1.0/2.0=-0.5$ï¼Œ**range(3,3)ä¸ºç©º**
   - $x[1]=(y[1]-sum(U[1,2]\cdot{x[2]}))/U[1,1]=(0.0+0.5)/1.0=0.5$
   - $x[0]=(y[0]-sum(U[0,2]\cdot{x[2]}+U[0,1]\cdot{x[1]}))/U[0,0]=(1.0-0.5)/1.0=0.5$

3. ==å¾—åˆ°ç¬¬ä¸€ç»„åˆ—å‘é‡ï¼ˆé€†çŸ©é˜µï¼‰çš„è§£==ï¼š$[0.5,0.5,-0.5]^{T}$

```py
def forward_sub(L, b):
    n = len(L)
    y = [0.0]*n
    for i in range(n):
        y[i] = b[i] - sum(L[i][j]*y[j] for j in range(i))
    return y

def backward_sub(U, y):
    n = len(U)
    x = [0.0]*n
    for i in reversed(range(n)):
        x[i] = (y[i] - sum(U[i][j]*x[j] for j in range(i+1, n))) / U[i][i]
    return x

def inverse_from_lu(L, U):
    n = len(L)
    invA = []
    for i in range(n):
        e = [0.0]*n
        e[i] = 1.0
        y = forward_sub(L, e)
        x = backward_sub(U, y)
        invA.append(x)
    # è½¬ç½®ä¸€ä¸‹ï¼Œå› ä¸ºæ¯ä¸ª x æ˜¯ä¸€åˆ—
    return [ [invA[j][i] for j in range(n)] for i in range(n) ]
```

$$
(C^{-1})^{T}=
\begin{bmatrix}
0.5 & 0.5 & -0.5 \\ -0.5 & 0.5 & 0.5 \\ 0.5 & -0.5 & 0.5
\end{bmatrix}
\xrightarrow{\text{è½¬ç½®å¯¹åº”}}
C^{-1}=
\begin{bmatrix}
0.5 & -0.5 & 0.5 \\ 0.5 & 0.5 & -0.5 \\ -0.5 & 0.5 & 0.5
\end{bmatrix}
$$

æœ€åä¸€æ­¥å°±æ˜¯çŸ©é˜µä¹˜æ³•ï¼Œæ²¡æœ‰ä»€ä¹ˆå¥½è¯´çš„ï¼Œåªæ˜¯å°è£…æˆäº†å‡½æ•°çš„å½¢å¼ï¼š

```py
def mat_mul(A, B):
    """æ‰‹å†™çŸ©é˜µä¹˜æ³• A x B"""
    m, n, p = len(A), len(A[0]), len(B[0])
    C = [[0.0]*p for _ in range(m)]
    for i in range(m):
        for j in range(p):
            for k in range(n):
                C[i][j] += A[i][k] * B[k][j]
    return C
```

ä½†æ˜¯å¾ˆé—æ†¾ï¼Œæ‰‹å†™çš„è¿™ä¸ªç®—æ³•ï¼Œä¸çŸ¥é“ä¸ºä»€ä¹ˆï¼ŒåŒæ ·æœ‰ç²¾åº¦è¯¯å·®é—®é¢˜ï¼Œå¯¼è‡´æµ®ç‚¹æ•°è¿‡å¤šæ—¶è®¡ç®—æœ‰è¯¯ã€‚LA6 ä¸­ä½¿ç”¨ np.cov() å‡½æ•°æ—¶åŒæ ·å‡ºç°äº†è¿™ä¸ªé—®é¢˜ã€‚

```py
# è¾“å…¥å†…å®¹
[[1, 0, 0], [0, 1, 0], [0, 0, 1]]
[[1, 2.3, 3], [4.4, 25, 6], [7.4, 8, 9]]

# é¢„æœŸè¾“å‡º
[[-0.6772268135904498, -0.012626262626262638, 0.23415977961432502],
[-0.01836547291092747, 0.05050505050505051, -0.02754820936639118],
[0.5731558004285277, -0.03451178451178451, -0.0569329660238751]]

# å®é™…è¾“å‡º
[[-0.6772268135904498, -0.012626262626262638, 0.23415977961432508],
[-0.01836547291092744, 0.050505050505050504, -0.027548209366391185],
[0.5731558004285277, -0.0345117845117845, -0.05693296602387511]]
```
