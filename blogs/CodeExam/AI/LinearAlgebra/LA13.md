---
title: LA13.描述性统计计算器
date: 2025/09/30
categories:
  - 每日一题
tags:
  - AI题库
  - 线性代数
---

#### 难度：简单

编写一个 Python 函数来计算给定数据集的各种描述性统计指标。该函数应采用数值列表或 NumPy 数组，并返回包含平均值、中位数、众数、方差、标准差、百分位数（第 25、50、75）和四分位数范围(IQR)的字典。需要计算的统计指标包括：

1. 平均值（mean）
2. 中位数（median）
3. 众数（mode）
4. 方差（variance）
5. 标准差（standard_deviation）
6. 25th 百分位数（25th_percentile）
7. 50th 百分位数（50th_percentile）
8. 75th 百分位数（75th_percentile）
9. 四分位距（interquartile_range）

- **输入描述**：输入为一行需要计算统计指标的数据集。
- **输出描述**：输出一个字典，包含以下键值对：
  - "mean": 平均值
  - "median": 中位数
  - "mode": 众数
  - "variance": 方差（保留 4 位小数）
  - "standard_deviation": 标准差（保留 4 位小数）
  - "25th_percentile": 第 25 百分位数
  - "50th_percentile": 第 50 百分位数
  - "75th_percentile": 第 75 百分位数
  - "interquartile_range": 四分位距

:::: code-group
::: code-group-item 代码框架

```py
import numpy as np
def descriptive_statistics(data):
	# Your code here
	stats_dict = {
        "mean": mean,
        "median": median,
        "mode": mode,
        "variance": np.round(variance,4),
        "standard_deviation": np.round(std_dev,4),
        "25th_percentile": percentiles[0],
        "50th_percentile": percentiles[1],
        "75th_percentile": percentiles[2],
        "interquartile_range": iqr
    }
	return {}

if __name__ == "__main__":
    data = eval(input())
    print(descriptive_statistics(data))
```

:::

::: code-group-item 示例 1

```py
# 输入：
[1, 2, 3, 4, 5]

# 输出：
{'mean': 3.0, 'median': 3.0, 'mode': 1, 'variance': 2.0, 'standard_deviation': 1.4142, '25th_percentile': 2.0, '50th_percentile': 3.0, '75th_percentile': 4.0, 'interquartile_range': 2.0}
```

:::
::::

---

#### 统计性描述的分析与作用

大多数的值都很好理解，这里对几个不常见的值做一个说明，首先是 ==众数（mode）==，它表示 **出现次数最多的数**。如果有多个并列出现最多的数，会返回一个列表。

其次是 ==百分位数（percentile）==，它的意思是 **有 25% 的数据比它小，75% 的数据比它大**，并不是简单的取 index = 25%。它的计算过程如下：

1. 对数据排序：[7, 3, 5, 9] --> [3, 5, 7, 9]
2. 找到对应位置：$(n-1)\cdot{p}$；n 表示数据数量，p 表示百分比。
3. 如果位置不是整数，就在相邻两个值之间 插值（线性插值），而不是直接四舍五入。

- **25th 百分位数**：$(4-1)\cdot{0.25}=0.75$，在 [0, 1] 之间，线性插值：$arr[0]+(arr[1]-arr[0])\cdot{p}=3+(5-3)\cdot{0.25}=3.5$。
- **75th 百分位数**：$(4-1)\cdot{0.75}=2.25$，在 [2, 3] 之间，线性插值：$7+(9-7)\cdot{0.75}=8.5$

最后是 ==四分位距（IQR, Interquartile Range）==，等于 **第 75 百分位数(Q3) - 第 25 百分位数(Q1)**，用来衡量 **数据中间 50% 的离散程度**，不受极端值的影响，比如：

- [1, 2, 3, 4, 5, 100]：$Q1=2+(3-2)\cdot{0.25}=2.25, Q3=4+(5-4)\cdot{0.75}=4.75, IQR=Q3-Q1=2.5$。

这一组 **统计性描述** 的九个指标，不是复杂的机器学习模型，而是帮助我们第一眼看清数据整体分布特征的“放大镜”，是 **探索性数据分析（EDA）** 的第一步。我们从 ==直觉、应用、局限== 三个方面来探究一下它们的作用：

1. ==平均值（mean）==：**直觉**：数据的“中心点”，整体水平。**应用**：公司 KPI（平均营收、平均点击率），医疗数据（平均寿命、平均血压）。**局限**：容易被极端值影响，比如 [1,2,3,100] 的平均值是 26.5，但大多数数据其实很小。
2. ==中位数（median）==：**直觉**：排好序后正中间的值，一半比它大、一半比它小。**应用**：收入统计（通常用中位数收入而不是平均值，因为极少数富豪会把平均值拉得很高）。房价、房租中位数。**局限**：不容易受极端值影响，更稳健。
3. ==众数（mode）==：**直觉**：最常见的数值或类别。**应用**：调查问卷（最常见的回答选项），图像处理（像素点最常见颜色 → 去噪），市场分析（最畅销产品、最热门价格区间）。**局限**：对于连续数值型数据，众数常常不直观（可能每个值都只出现一次）。
4. ==方差（variance）、标准差（standard_deviation）==：**直觉**：衡量数据的离散程度，波动大不大。**应用**：股票市场（高标准差 → 高风险波动；低标准差 → 稳定），制造业质量控制（产品重量/尺寸稳定性），实验重复性分析（误差范围）。**局限**：方差是平方单位，不直观；标准差更常用（和原始数据同单位）。
5. ==百分位数（25th, 50th, 75th）==：**直觉**：告诉你数据在某个百分比位置的值。**应用**：医学（“一个孩子的身高在全国 75 百分位 → 比 75% 的孩子高”），网络延迟（P95 延迟：95% 请求在这个时间内完成 → 常用于 SLA）。
6. ==四分位距（interquartile_range, IQR）==：**直觉**：Q3 − Q1，代表“中间 50% 数据”的范围。**应用**：异常值检测（常用 IQR rule：数据 < Q1−1.5IQR 或 > Q3+1.5IQR 判为 outlier）；金融风控（稳健的波动区间，不被极端值干扰）；数据建模时，衡量数据的“有效集中区间”。

#### 解题思路 1：Pandas + Numpy

Pandas 有两种非常通用的框架，以 Excel 表格的方式来看，==pd.Series()== 表示一行/一列的数据，==pd.DataFrame()== 表示一个表格的数据，也就是二维数组的形式。它内置了很多 Excel 常用的数学计算的方法，实现的方式如代码所示。

Pandas 的 Series/ DataFrame 内部大部分运算都是调用 NumPy 的向量化函数（np.mean, np.var, np.std 等）来处理的。所以性能上和 NumPy 差不多，优势主要是接口更方便，对缺失值（NaN）处理更好，而且方便做列/行操作。

```py
import pandas as pd
import numpy as np

def descriptive_statistics(data):
    s = pd.Series(data)
    return {
        "mean": s.mean(),
        "median": s.median(),
        "mode": s.mode().iloc[0] if not s.mode().empty else None,
        "variance": round(np.var(s, ddof=0), 4),
        "standard_deviation": round(np.std(s, ddof=0), 4),
        "25th_percentile": s.quantile(0.25),
        "50th_percentile": s.quantile(0.5),
        "75th_percentile": s.quantile(0.75),
        "interquartile_range": s.quantile(0.75) - s.quantile(0.25)
    }
```

需要说明的有两点。其一，众数（mode）之所以写这么长，是避免代码的报错。==s.mode()== 的返回值不是单个数，而是一个 Series，因为众数可能不止一个。所以这时候就要取 ==.iloc[0]==,表示只取第一个众数，简化成一个值返回。

写到这里其实就能通过了。后面的判断表示，如果 Series 不为空，才从 s.mode().iloc[0] 中取值，否则返回 None。避免 Series 为空时，出现代码的报错行为，是一步安全性的冗余操作。

其二，方差和标准差的计算默认是这么写的（默认 ddof=1，表示样本方差/标准差）：

- "variance": s.var(),
- "standard_deviation": s.std(),

但是 **样本方差/标准差（无偏估计）** 计算出来的结果与给出的结果有误差，所以我尝试了将其改为 **总体方差/标准差（有偏估计）**，这一次对了。无偏估计就是归一化时使用 $\frac{1}{n-1}$，有偏估计就是 $\frac{1}{n}$，在 LA6 中有说到过。

#### 解题思路 2：Numpy 处理

刚说了，Pandas 的计算大多都是调用的 Numpy 对于向量的计算函数，所以本质上我们也可以通过 Numpy 直接进行计算。唯独需要手动计算的是 **众数（mode）**，我们可以通过计算 **唯一值 + 出现次数** 的方式，得到众数结果：

- ==np.unique(arr, return_counts=True)==：返回两个数组，**values 数组** 获取去重、排序后的所有唯一值；**counts 数组** 获取每个唯一值出现的次数。举例说明：

```py
arr = [1,2,2,3,3,4]
values = [1,2,3,4]
counts = [1,2,2,1]
```

- ==max_count = counts.max()==：找到最大频数。这里就是 max_count = 2。
- ==values[counts == max_count]==：找出所有最大频数的众数候选。NumPy 允许我们用布尔数组来索引另一个数组。规则是，**布尔数组和被索引数组长度要一致**。位置为 True 的，就取出来；为 False 的，就跳过。

```py
values[counts == max_count]
values[[False, True, True, False]]
[2, 3]
```

- ==mode_candidates[0]==：取第一个众数。

```py
import numpy as np

def mode_numpy(arr):
    """返回数组的众数（如有多个众数，返回第一个）"""
    values, counts = np.unique(arr, return_counts=True)
    max_count = counts.max()
    mode_candidates = values[counts == max_count]
    return mode_candidates[0]

def descriptive_statistics(data):
    arr = np.array(data)  # 转成 NumPy array

    p25 = np.percentile(arr, 25)
    p50 = np.percentile(arr, 50)
    p75 = np.percentile(arr, 75)

    return {
        "mean": np.mean(arr),
        "median": np.median(arr),
        "mode": mode_numpy(arr),
        "variance": round(np.var(arr, ddof=0), 4),
        "standard_deviation": round(np.std(arr, ddof=0), 4),
        "25th_percentile": p25,
        "50th_percentile": p50,
        "75th_percentile": p75,
        "interquartile_range": p75 - p25,
    }
```

#### 解题思路 3：Python 纯手搓

知道对应公式，对不同的计算封装成函数调用即可。难到是不难，就是有点麻烦。

```py
from collections import Counter

def mean(arr):
    return sum(arr) / len(arr) if arr else None

def median(arr, n):
    mid = n // 2
    if n % 2 == 0:
        result = (arr[mid - 1] + arr[mid]) / 2
        return float(result)
    else:
        return float(arr[mid])

def mode(arr):
    counts = Counter(arr)
    max_count = max(counts.values())
    mode_candidates = [k for k, v in counts.items() if v == max_count]
    return mode_candidates[0]  # 取第一个众数

def variance(arr):
    m = mean(arr)
    m1 = sum((x - m) ** 2 for x in arr) / len(arr)
    return round(m1, 4)

def standard_deviation(arr):
    var = variance(arr)
    var1 = var ** 0.5 if var is not None else None
    return round(var1, 4)

def percentiles(arr, n):
    def percentile(p):
        pos = (n - 1) * p
        i = int(pos)
        frac = pos - i
        if i + 1 < n:
            return arr[i] * (1 - frac) + arr[i + 1] * frac
        else:
            return arr[i]

    q25 = percentile(0.25)
    q50 = percentile(0.5)
    q75 = percentile(0.75)
    iqr = q75 - q25
    return q25, q50, q75, iqr

def descriptive_statistics(arr):
    arr = sorted(arr)
    n = len(arr)
    q25, q50, q75, iqr = percentiles(arr, n)

    return {
        "mean": mean(arr),
        "median": median(arr, n),
        "mode": mode(arr),
        "variance": variance(arr),
        "standard_deviation": standard_deviation(arr),
        "25th_percentile": q25,
        "50th_percentile": q50,
        "75th_percentile": q75,
        "interquartile_range": iqr
    }
```
