---
title: LA18.矩阵变换
date: 2025/10/03
categories:
  - 每日一题
tags:
  - AI题库
  - 线性代数
---

#### 难度：中等

编写一个 Python 函数，使用以下操作 $T^{-1}AS$ 转换给定矩阵 A ，其中 T 和 S 是可逆矩阵。该函数应首先验证矩阵 T 和 S 是否可逆，然后执行转换。如果没有解决方案，则返回-1。

- **输入描述**：第 1 行输入矩阵 A，第 2 行输入矩阵 T，第 3 行输入矩阵 S。
- **输出描述**：输出转换后的矩阵。返回形式以嵌套 List 形式，结果保留三位小数。

:::: code-group
::: code-group-item 代码框架

```py
import numpy as np
def transform_matrix(A,T,S):
    # 补全代码

# 主程序
if __name__ == "__main__":
    # 输入
    ndarrayA = input()
    ndarrayT = input()
    ndarrayS = input()

    # 处理输入
    import ast
    A = ast.literal_eval(ndarrayA)
    T = ast.literal_eval(ndarrayT)
    S = ast.literal_eval(ndarrayS)

    # 调用函数计算
    output = transform_matrix(A,T,S)

    # 输出结果
    print(output)
```

:::

::: code-group-item 示例 1

```py
# 输入：
[[4, 2], [1, 3]]
[[1, 0], [0, 1]]
[[2, 1], [1, 2]]

# 输出：
[[10.0, 8.0], [5.0, 7.0]]
```

:::
::::

---

#### 解题思路 1：Numpy

LA7 中说过，逆矩阵的定义与数学定理。矩阵行列式 **不为零** 时，矩阵一定可逆；反之，如果 $det(M) = 0$，说明它不可逆（奇异矩阵）。所以可逆的判定就很简单了，直接判断 ==np.linalg.det()== 是否为零即可。之后便是按要求做矩阵乘法。

```py
import numpy as np
def transform_matrix(A,T,S):
    A = np.array(A, dtype=float)
    T = np.array(T, dtype=float)
    S = np.array(S, dtype=float)

    # 检查可逆性
    if np.linalg.det(T) == 0 or np.linalg.det(S) == 0:
        return -1

    # 计算 T^-1 * A * S
    result = np.linalg.inv(T) @ A @ S

    # 保留三位小数，转嵌套 list
    return np.round(result, 3).tolist()
```

#### 解题思路 2：Python

和 LA7 一样的函数，一样的配方，这里能跑通，LA7 跑不通。emmm，再去凹一凹。

这里的矩阵可逆的判定，因为它只用了 2x2 的矩阵，所以我的函数 det 也只写了 2x2 的行列式求法。

```py
def lu_decomposition(A):
    n = len(A)
    L = [[0.0] * n for _ in range(n)]
    U = [[0.0] * n for _ in range(n)]

    for i in range(n):
        L[i][i] = 1.0  # 对角线 L[i][i] = 1

        # 计算 U 的第 i 行
        for j in range(i, n):
            s = sum(L[i][k] * U[k][j] for k in range(i))
            U[i][j] = A[i][j] - s

        # 计算 L 的第 i 列
        for j in range(i + 1, n):
            s = sum(L[j][k] * U[k][i] for k in range(i))
            L[j][i] = (A[j][i] - s) / U[i][i]

    return L, U


def forward_sub(L, b):
    n = len(L)
    y = [0.0] * n
    for i in range(n):
        y[i] = b[i] - sum(L[i][j] * y[j] for j in range(i))
    return y


def backward_sub(U, y):
    n = len(U)
    x = [0.0] * n
    for i in reversed(range(n)):
        x[i] = (y[i] - sum(U[i][j] * x[j] for j in range(i + 1, n))) / U[i][i]
    return x


def inverse_from_lu(L, U):
    n = len(L)
    invA = []
    for i in range(n):
        e = [0.0] * n
        e[i] = 1
        y = forward_sub(L, e)
        x = backward_sub(U, y)
        invA.append(x)
    # 转置一下，因为每个 x 是一列
    return [[invA[j][i] for j in range(n)] for i in range(n)]


def mat_mul(A, B):
    """手写矩阵乘法 A x B"""
    m, n, p = len(A), len(A[0]), len(B[0])
    C = [[0.0]*p for _ in range(m)]
    for i in range(m):
        for j in range(p):
            for k in range(n):
                C[i][j] += A[i][k] * B[k][j]
    return C


def det(x):
    return x[0][0]*x[1][1] - x[0][1]*x[1][0]


def transform_matrix(A, T, S):
    # 检查可逆性
    if det(T) == 0 or det(S) == 0:
        return -1

    # 计算 T^-1 * A * S
    L, U = lu_decomposition(T)  # 手写LU分解
    T_inv = inverse_from_lu(L, U)  # 解线性方程组，求逆矩阵
    result_temp = mat_mul(T_inv, A)
    result = mat_mul(result_temp, S)

    # 保留 2 位小数，转嵌套 list
    return [[round(x, 2) for x in row] for row in result]
```
