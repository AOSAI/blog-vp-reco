---
title: LA21.使用Jacobi方法求解线性方程组
date: 2025/10/14
categories:
  - 每日一题
tags:
  - AI题库
  - 线性代数
---

#### 难度：中等

编写一个 Python 函数，使用 Jacobi 方法求解由 Ax = b 给出的线性方程组。该函数应迭代 n 次，将每个中间解四舍五入到小数点后四位，并返回近似解 x。

- **输入描述**：第 1 行输入 A，第 2 行输入 b，第 3 行输入 n。
- **输出描述**：输出近似解 x。返回结果以 List 形式即可。

:::: code-group
::: code-group-item 代码框架

```py
import numpy as np

def solve_jacobi(A, b, n) :
    # 补全代码

if __name__ == "__main__":
    # 输入
    ndarrayA = input()
    ndarrayB = input()
    n = input()

    # 处理输入
    import ast
    A = ast.literal_eval(ndarrayA)
    b = ast.literal_eval(ndarrayB)
    n = int(n)

    # 调用函数计算, 输出结果
    output = solve_jacobi(A,b,n)
    print(output)
```

:::

::: code-group-item 示例 1

```py
# 输入：
[[4, -1, 0], [-1, 4, -1], [0, -1, 3]]
[15, 10, 10]
10

# 输出：
[4.9997, 4.9997, 4.9996]
```

:::
::::

---

#### 雅克比迭代法

==雅克比（Jacobi）迭代法== 通常用于求解线性方程组，或者求解矩阵的特征值。我们来一个实际的例子，要求解方程组 $A\cdot{x}=b$，假设现在有方程组如下：

$$
\begin{cases}
8x_{1}-3x_{2}+2x_{3}=20 \\
4x_{1}+11x_{2}-x_{3}=33 \\
6x_{1}+3x_{2}+12x_{3}=36 \\
\end{cases}
$$

$$
A=\begin{bmatrix} 8 & -3 & 2 \\ 4 & 11 & -1 \\ 6 & 3 & 12 \end{bmatrix} \quad
x=\begin{bmatrix} x_{1} \\ x_{2} \\ x_{3} \end{bmatrix} \quad
b=\begin{bmatrix} 20 \\ 33 \\ 36 \end{bmatrix} \quad
$$

我们可以改写一下方程组，得出该例子的迭代公式：

$$
\begin{cases}
x_{1}=(20+3x_{2}-2x_{3})/8 \\[0.5em]
x_{2}=(33-4x_{1}+x_{3})/33 \\[0.5em]
x_{3}=(36-6x_{1}-3x_{2})/36
\end{cases}
\xRightarrow{迭代公式}
\begin{cases}
x_{1}^{k+1}=(20+3x_{2}^{k}-2x_{3}^{k})/8 \\[0.5em]
x_{2}^{k+1}=(33-4x_{1}^{k}+x_{3}^{k})/33 \\[0.5em]
x_{3}^{k+1}=(36-6x_{1}^{k}-3x_{2}^{k})/36
\end{cases}
$$

因为我们一开始不知道真正的 x，就假设一个初值 $x^{(0)}=[x_{1},x_{2},x_{3}]^{T}=[0,0,0]^{T}$，然后用上面的公式不断更新每个分量。需要注意的是，Jacobi 方法中，计算新一轮 $x_{i}^{(k+1)}$ 时，使用上一轮的全部旧值 $x_{j}^{(k)}$。

另外，Jacobi 并不是所有矩阵都能收敛。通常要求：**A 是严格对角占优矩阵**（对角元素的绝对值大于该行其它元素绝对值之和），满足的话一般都可以收敛。

#### 解题思路 1：Python 手搓核弹

手写的思路和上述过程是一致的，但是有一个小点需要注意，如果真的按照题目要求所说，把每一个中间值都四舍五入到 4 位数，最后是有误差的，所以我在中间值的时候保留了 2 位小数。

```py
def solve_jacobi(A, b, n):
    m = len(b)
    x = [0.0 for _ in range(m)]  # 初始向量全为0

    for index in range(n):  # 迭代n次
        x_new = [0.0 for _ in range(m)]
        for i in range(m):
            s = 0.0
            for j in range(m):
                if j != i:
                    s += A[i][j] * x[j]  # 使用旧的x
            x_new[i] = (b[i] - s) / A[i][i]

        if index != n - 1:
            x = [round(val, 6) for val in x_new]
        else:
            x = [round(val, 4) for val in x_new]

    return x
```

```py
第1轮： [3.75, 2.5, 3.333333]               第2轮： [4.375, 4.270833, 4.166667]
第3轮： [4.817708, 4.635417, 4.756944]      第4轮： [4.908854, 4.893663, 4.878472]
第5轮： [4.973416, 4.946832, 4.964554]      第6轮： [4.986708, 4.984492, 4.982277]
第7轮： [4.996123, 4.992246, 4.994831]      第8轮： [4.998062, 4.997738, 4.997415]
第9轮： [4.999434, 4.998869, 4.999246]      第10轮： [4.9997, 4.9997, 4.9996]
```

#### 解题思路 2：Numpy 处理

Numpy 的话就不用手动计算每个对应位置了:

1. 使用 **D = np.diag(A)** 函数提取矩阵 A 的对角线元素;
2. 使用 **np.diagflat(D)** 构造一个对角线元素为 D，其余元素为 0 的矩阵；
3. 用 **R = A - np.diagflat(D)** 把 A 的对角线全部清零；
4. 最后，使用迭代公式直接计算即可：**x_new = (b - np.dot(R, x)) / D**

```py
import numpy as np

def solve_jacobi(A, b, n):
    A = np.array(A, dtype=float)
    b = np.array(b, dtype=float)
    x = np.zeros_like(b)
    D = np.diag(A)
    R = A - np.diagflat(D)

    for index in range(n):
        x_new = (b - np.dot(R, x)) / D

        if index == n-1:
            x = np.round(x_new, 4)
            break
        x = np.round(x_new, 6)

    return x.tolist()
```
