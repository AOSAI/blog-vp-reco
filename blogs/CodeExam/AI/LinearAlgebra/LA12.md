---
title: LA12.计算向量之间的余弦相似度
date: 2025/09/30
categories:
  - 每日一题
tags:
  - AI题库
  - 线性代数
---

#### 难度：简单

实现一个函数来计算两个向量之间的余弦相似度。余弦相似度是通过测量两个向量之间的夹角的余弦值来度量它们之间的相似性。

- **输入描述**：
  1. 第一行为向量 v1，可以是一维或二维数组
  2. 第二行为向量 v2，维度需要与 v1 相同
- **输出描述**：输出一个浮点数，表示两个向量之间的余弦相似度，结果保留 3 位小数。

:::: code-group
::: code-group-item 代码框架

```py
import numpy as np

def cosine_similarity(v1, v2):
	# Implement your code here
    return round(val, 3)

if __name__ == "__main__":
    v1 = np.array(eval(input()))
    v2 = np.array(eval(input()))
    print(cosine_similarity(v1, v2))
```

:::

::: code-group-item 示例 1

```py
# 输入：
[1, 2, 3]
[4, 5, 6]

# 输出：
0.975
```

:::
::::

---

#### 衡量相关性/相似度的指标

1. 空间向量类：

- 欧氏距离 (Euclidean distance)：衡量几何直线距离，越小越相似。
- 曼哈顿距离 (Manhattan / L1 distance)：绝对值差的和，适合稀疏特征。
- 切比雪夫距离 (Chebyshev distance)：看坐标差的最大值。
- 闵可夫斯基距离 (Minkowski distance)：欧氏/曼哈顿的推广。
- ==马氏距离 (Mahalanobis distance)==：欧氏距离的协方差加权版，能考虑特征的尺度和相关性。
- ==汉明距离 (Hamming distance)==：曼哈顿距离的离散特例（仅对 0/1 向量）。

2. 相似度类（归一化后）：

- 点积 (Dot product)：没有归一化的余弦相似度，会受向量长度影响。
- ==余弦相似度 (Cosine similarity)==：基于夹角，等价于归一化点积。
- 雅卡尔相似度 (Jaccard similarity)：常用于集合，但向量（特别是二值向量）也可用。
- Dice 系数 (Sørensen–Dice coefficient)：类似 Jaccard，用于比较重叠度。

3. 统计相关性类：

- 皮尔逊相关系数 (Pearson correlation coefficient)：衡量线性相关，范围 -1 ~ 1。
- 斯皮尔曼等级相关系数 (Spearman rank correlation)：非线性单调关系也能捕捉。
- 肯德尔相关系数 (Kendall’s tau)：基于排序一致性。

4. 信息论类：

- KL 散度 (Kullback–Leibler divergence)：衡量两个分布的差异（非对称）。
- JS 散度 (Jensen–Shannon divergence)：对称的 KL 变体，更常用。
- 互信息 (Mutual Information)：衡量共享信息量。

#### 余弦相似度

==余弦相似度（Cosine Similarity）== 是一种用于度量两个向量之间相似性的方法，通常在多维空间中使用。它衡量了两个向量之间夹角的余弦值，从而提供了一种评估它们之间关系的方式。数学计算公式如下：

$$
\text{Cosine Similarity}(A,B) = \frac{\vec{A}\cdot{\vec{B}}}{||\vec{A}||+||\vec{B}||}
$$

其中，A 和 B 是要比较的向量；||A|| 与 ||B|| 表示向量的模长，通过计算每个向量元素的平方和，然后取平方根得到。之所以说它是归一化的向量点积，因为它除以了自己的模长，让范围在 [-1, 1] 之间。也是因此，它只受方向的干扰，不受长度的影响，适用于任何维度向量的比较。

- ==越接近 1==:表示两个向量之间的的方向越靠近，相似度越高。
- ==等于 0 时==：表示两个向量之间不存在线性关系，是不相关的。
- ==越接近 -1==:表示两个向量在多维空间中的方向正好相反，它们是完全不同的。

余弦相似性通常用于文本处理、信息检索、推荐系统和聚类分析等领域：

- **文本处理（NLP）**：在自然语言处理中，可以使用余弦相似性来比较文档、句子或词向量，以确定它们之间的相似性，用于信息检索、文本分类和推荐系统。
- **图像处理（CV）**：在计算机视觉中，可以使用余弦相似性来比较图像特征向量，用于图像检索和相似图像查找。
- **推荐系统（RS）**：在推荐系统中，可以使用余弦相似性来比较用户与商品之间的偏好向量，从而提供个性化的推荐。
- **聚类分析（CA）**：在聚类分析中，余弦相似性可用于度量样本之间的相似性，从而将相似的样本聚集在一起。

#### 解题思路 1：Numpy

Numpy 中没有现成的函数，但是可以通过范数函数简化计算步骤，==np.linalg.norm(x, ord)== 函数用于计算 向量/矩阵 范数，主要区别在于 ord 这个参数：

| 向量                   | 参数         | 矩阵                 | 参数         |
| ---------------------- | ------------ | -------------------- | ------------ |
| L1 范数（曼哈顿）      | 1            | Frobenius 范数       | 'fro'        |
| L2 范数（欧几里得）    | ==2 / None== | 核范数（奇异值和）   | 'nuc'        |
| L∞ 范数（最大绝对值）  | np.inf       | 谱范数（最大奇异值） | ==2 / None== |
| L-∞ 范数（最小绝对值） | -np.inf      | 列和的最大值         | 1            |
| Lp 范数（一般形式）    | p            | 行和的最大值         | np.inf       |

计算步骤如下：

1. 使用 ==v1 @ v2== 计算向量/矩阵乘法。
2. 使用 ==np.linalg.norm(v1/v2)== 计算 L2 范数，两者相乘。
3. 最后用向量 ==除以== L2 范数就得到了结果。

一个很有意思的点，题目说 v1 可以是一维或二维数组，并且 v2 的维度必须和 v1 相同。但是，它是输入描述的内容，示例中也没有给出如果不一致返回什么，所以我们并不需要考虑代码的鲁棒性（健壮程度）。

```py
import numpy as np

def cosine_similarity(v1, v2):
    val = (v1 @ v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))
    return round(val, 3)
```

#### 解题思路 1：Python 数组手搓

向量的余弦相似度算法很好理解，但是矩阵应该怎么理解？普通的矩阵乘法 A @ B 结果还是一个矩阵，每个元素位置都有自己的和。而矩阵版的余弦相似度使用的是 ==Frobenius 内积==：**当 A、B 形状相同（same shape）时，对应位置元素相乘并求和，它是一个标量**。同理，范数也是用的是 ==Frobenius 范数==：**对所有元素求平方和，最后统一开方**。

但是很遗憾，牛客网目前的 LA12 题目中，提交的测试用例实际也只有 Vector 向量，并没有 Matrix 矩阵。所以我将代码分为了 **仅向量** 与 **向量/矩阵通用** 两个版本，使用简化的前者版本就可以通过提交测试：

1. 第一步，构造向量乘法的函数：

:::: code-group
::: code-group-item 余弦相似度 - 仅向量乘法

```py
def dot_vector(v1, v2):
    """向量乘法 A x B"""
    assert len(v1) == len(v2), "向量长度不一致"
    return sum(v1[i] * v2[i] for i in range(len(v1)))
```

:::

::: code-group-item 余弦相似度 - 向量矩阵通用乘法

```py
def dot_vector(v1, v2):
    """向量乘法 A x B"""
    assert len(v1) == len(v2), "向量长度不一致"
    return sum(v1[i] * v2[i] for i in range(len(v1)))


def dot_matrix(A, B):
    """Frobenius: 逐元素相乘再求和"""
    m, n, p, q = len(A), len(B), len(A[0]), len(B[0])
    assert m == n and q == p, "矩阵维度不匹配"

    C = sum([A[i][j] * B[i][j] for i in range(m) for j in range(p)])
    return C


def multiply(A, B):
    """通用接口：自动判断向量点积 or 矩阵乘法"""
    if isinstance(A[0], (int, float)) and isinstance(B[0], (int, float)):
        return dot_vector(A, B)

    if isinstance(A[0], list) and isinstance(B[0], list):
        return dot_matrix(A, B)

    raise ValueError("输入必须都是向量或矩阵，且维度匹配")
```

:::
::::

2. 第二步，构造 L2 范数的计算函数：

:::: code-group
::: code-group-item L2 范数

```py
def norm_dim1(x):
  return sum(val ** 2 for val in x) ** 0.5
```

:::

::: code-group-item 通用范数 L2 与 Frobenius

```py
def multiply_norm(x):
    if isinstance(x[0], (int, float)):
        return sum(val ** 2 for val in x) ** 0.5
    elif isinstance(x[0], list):
        return sum(val ** 2 for row in x for val in row) ** 0.5
    else:
        raise ValueError("只支持一维向量或二维矩阵")
```

:::
::::

3. 第三步，获取输入的值与计算函数的调用：

:::: code-group
::: code-group-item 仅向量

```py
def cosine_similarity(v1, v2):
    mul = dot_vector(v1, v2)
    L2 = norm_dim1(v1) * norm_dim1(v2)
    val = mul / L2
    return round(val, 3)

if __name__ == "__main__":
    v1 = eval(input())
    v2 = eval(input())
    print(cosine_similarity(v1, v2))
```

:::

::: code-group-item 向量矩阵通用

```py
def cosine_similarity(v1, v2):
    mul = multiply(v1, v2)
    L2 = multiply_norm(v1) * multiply_norm(v2)
    val = mul / L2
    return round(val, 3)

if __name__ == "__main__":
    v1 = eval(input())
    v2 = eval(input())
    print(cosine_similarity(v1, v2))
```

:::
::::
